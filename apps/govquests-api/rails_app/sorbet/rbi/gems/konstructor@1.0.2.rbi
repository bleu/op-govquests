# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `konstructor` gem.
# Please instead update this file by running `bin/tapioca gem konstructor`.


# source://konstructor//lib/konstructor/core_ext.rb#2
class Class < ::Module
  include ::Konstructor::KonstructorMethod
end

# source://konstructor//lib/konstructor/version.rb#1
module Konstructor
  extend ::MonitorMixin

  class << self
    # source://konstructor//lib/konstructor/main.rb#93
    def declare(klass, new_method_names); end

    # Once method is a konstructor, it is always a konstructor, this differs
    # from the way private, protected works. If overriding method isn't repeatedly
    # marked as private it becomes public.
    #
    # @return [Boolean]
    #
    # source://konstructor//lib/konstructor/main.rb#84
    def declared?(klass, method_name); end

    # @return [Boolean]
    #
    # source://konstructor//lib/konstructor/main.rb#77
    def default?(name); end

    # @return [Boolean]
    #
    # source://konstructor//lib/konstructor/main.rb#106
    def is?(klass, method_name); end

    # source://konstructor//lib/konstructor/main.rb#100
    def method_added_to_klass(klass, method_name); end

    # @return [Boolean]
    #
    # source://konstructor//lib/konstructor/main.rb#73
    def reserved?(name); end

    private

    # Overriden append_features prevents default behavior
    # of including all the constants, variables to the base class.
    # It adds only one method 'konstructor'.
    #
    # source://konstructor//lib/konstructor/main.rb#132
    def append_features(klass); end

    # source://konstructor//lib/konstructor/main.rb#112
    def get_factory(klass); end

    # source://konstructor//lib/konstructor/main.rb#121
    def get_or_init_factory(klass); end

    # source://konstructor//lib/konstructor/main.rb#116
    def init_factory(klass); end

    # source://konstructor//lib/konstructor/main.rb#125
    def setup_method_added_hook(klass); end
  end
end

# source://konstructor//lib/konstructor/main.rb#67
Konstructor::DEFAULT_NAMES = T.let(T.unsafe(nil), Array)

# Raised if declaring inherited method as constructor.
#
# source://konstructor//lib/konstructor/exceptions.rb#17
class Konstructor::DeclaringInheritedError < ::Konstructor::Error
  # @return [DeclaringInheritedError] a new instance of DeclaringInheritedError
  #
  # source://konstructor//lib/konstructor/exceptions.rb#18
  def initialize(name); end
end

# Base class for all Konstructor errors.
#
# source://konstructor//lib/konstructor/exceptions.rb#4
class Konstructor::Error < ::StandardError; end

# @private
#
# source://konstructor//lib/konstructor/factory.rb#3
class Konstructor::Factory
  # @return [Factory] a new instance of Factory
  #
  # source://konstructor//lib/konstructor/factory.rb#5
  def initialize(klass); end

  # source://konstructor//lib/konstructor/factory.rb#13
  def declare(new_names); end

  # @return [Boolean]
  #
  # source://konstructor//lib/konstructor/factory.rb#22
  def declared?(name); end

  # source://konstructor//lib/konstructor/factory.rb#26
  def method_added_to_klass(name); end

  private

  # @return [Boolean]
  #
  # source://konstructor//lib/konstructor/factory.rb#52
  def declared_in_self?(name); end

  # @return [Boolean]
  #
  # source://konstructor//lib/konstructor/factory.rb#56
  def declared_in_superclass?(name); end

  # source://konstructor//lib/konstructor/factory.rb#107
  def define_factory(name); end

  # source://konstructor//lib/konstructor/factory.rb#125
  def mark_as_private(name); end

  # @return [Boolean]
  #
  # source://konstructor//lib/konstructor/factory.rb#91
  def method_defined?(klass, name); end

  # @return [Boolean]
  #
  # source://konstructor//lib/konstructor/factory.rb#83
  def method_in_hierarchy?(name); end

  # @return [Boolean]
  #
  # source://konstructor//lib/konstructor/factory.rb#87
  def method_on_superclass?(name); end

  # source://konstructor//lib/konstructor/factory.rb#40
  def next_method_is_konstructor!; end

  # @return [Boolean]
  #
  # source://konstructor//lib/konstructor/factory.rb#48
  def next_method_is_konstructor?; end

  # this method is idempotent
  #
  # source://konstructor//lib/konstructor/factory.rb#96
  def process_declaration(name); end

  # source://konstructor//lib/konstructor/factory.rb#68
  def process_new_names(new_names); end

  # source://konstructor//lib/konstructor/factory.rb#44
  def reset_next_method_is_konstructor!; end

  # source://konstructor//lib/konstructor/factory.rb#129
  def validate_name!(name); end
end

# Raised if <code>konstructor</code> is used inside module.
#
# source://konstructor//lib/konstructor/exceptions.rb#25
class Konstructor::IncludingInModuleError < ::Konstructor::Error
  # @return [IncludingInModuleError] a new instance of IncludingInModuleError
  #
  # source://konstructor//lib/konstructor/exceptions.rb#26
  def initialize(base); end
end

# source://konstructor//lib/konstructor/main.rb#8
module Konstructor::KonstructorMethod
  private

  # konstructor                 -> nil or
  # konstructor(symbol, ...)    -> nil or
  # konstructor(string, ...)    -> nil
  #
  # If used without params, declares next method as constructor.
  #
  #   module SomeClass
  #     attr_reader :val
  #
  #     konstructor
  #     def create(val)
  #       @val = val
  #     end
  #   end
  #
  # If names are given, call can be placed anywhere, only methods with
  # those names will be declared as constructors.
  #
  #   module SomeClass
  #     attr_reader :val
  #
  #     def create(val)
  #       @val = val
  #     end
  #
  #     konstructor :create, :recreate
  #
  #     def recreate(val)
  #       @val = val * 2
  #     end
  #   end
  #
  # <em>then:</em>
  #
  #   SomeClass.new.val
  #   => nil
  #   SomeClass.create(3).val
  #   => 3
  #   SomeClass.recreate(3).val
  #   => 6
  #
  # Can be used multiple times with various arguments,
  # all calls add up without overwriting each other.
  #
  # Can raise several errors inheriting from <code>Konstructor::Error</code>:
  #   ReservedNameError
  #   DeclaringInheritedError
  #   IncludingInModuleError
  #
  # source://konstructor//lib/konstructor/main.rb#61
  def konstructor(*several_variants); end
end

# source://konstructor//lib/konstructor/main.rb#68
Konstructor::RESERVED_NAMES = T.let(T.unsafe(nil), Array)

# Raised if reserved names <code>new</code> or <code>initialize</code>
# are used in declaration.
#
# source://konstructor//lib/konstructor/exceptions.rb#9
class Konstructor::ReservedNameError < ::Konstructor::Error
  # @return [ReservedNameError] a new instance of ReservedNameError
  #
  # source://konstructor//lib/konstructor/exceptions.rb#10
  def initialize(name); end
end

# @private
#
# source://konstructor//lib/konstructor/simple_method_hook.rb#3
module Konstructor::SimpleMethodHook
  private

  # source://konstructor//lib/konstructor/simple_method_hook.rb#7
  def method_added(name); end

  class << self
    # source://konstructor//lib/konstructor/simple_method_hook.rb#12
    def setup(base); end
  end
end

# source://konstructor//lib/konstructor/version.rb#2
Konstructor::VERSION = T.let(T.unsafe(nil), String)
