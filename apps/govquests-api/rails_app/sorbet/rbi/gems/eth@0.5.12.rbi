# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `eth` gem.
# Please instead update this file by running `bin/tapioca gem eth`.


# Provides the {Eth} module.
#
# source://eth//lib/eth.rb#16
module Eth
  private

  # Attribute for password.
  #
  # source://eth//lib/eth/client/http.rb#76
  def password; end
end

# Provides a Ruby implementation of the Ethereum Application Binary Interface (ABI).
# ref: https://docs.soliditylang.org/en/develop/abi-spec.html
#
# source://eth//lib/eth/abi.rb#24
module Eth::Abi
  extend ::Eth::Abi

  # Decodes Application Binary Interface (ABI) data. It accepts multiple
  # arguments and decodes using the head/tail mechanism.
  #
  # @param types [Array] the ABI to be decoded.
  # @param data [String] ABI data to be decoded.
  # @raise [DecodingError]
  # @return [Array] the decoded ABI data.
  #
  # source://eth//lib/eth/abi.rb#73
  def decode(types, data); end

  # Encodes Application Binary Interface (ABI) data. It accepts multiple
  # arguments and encodes using the head/tail mechanism.
  #
  # @param types [Array] types to be ABI-encoded.
  # @param args [Array] values to be ABI-encoded.
  # @return [String] the encoded ABI data.
  #
  # source://eth//lib/eth/abi.rb#42
  def encode(types, args); end
end

# Provides a utility module to assist decoding ABIs.
#
# source://eth//lib/eth/abi/decoder.rb#24
module Eth::Abi::Decoder
  extend ::Eth::Abi::Decoder

  # Decodes primitive types.
  #
  # @param type [Eth::Abi::Type] type to be decoded.
  # @param data [String] encoded primitive type data string.
  # @raise [DecodingError] if decoding fails for type.
  # @return [String] the decoded data for the type.
  #
  # source://eth//lib/eth/abi/decoder.rb#101
  def primitive_type(type, data); end

  # Decodes a specific value, either static or dynamic.
  #
  # @param type [Eth::Abi::Type] type to be decoded.
  # @param arg [String] encoded type data string.
  # @raise [DecodingError] if decoding fails for type.
  # @return [String] the decoded data for the type.
  #
  # source://eth//lib/eth/abi/decoder.rb#33
  def type(type, arg); end
end

# Provides a special decoding error if anything fails to decode.
#
# source://eth//lib/eth/abi.rb#31
class Eth::Abi::DecodingError < ::StandardError; end

# Provides a utility module to assist encoding ABIs.
#
# source://eth//lib/eth/abi/encoder.rb#24
module Eth::Abi::Encoder
  extend ::Eth::Abi::Encoder

  # Encodes primitive types.
  #
  # @param type [Eth::Abi::Type] type to be encoded.
  # @param arg [String|Number] value to be encoded.
  # @raise [EncodingError] if value does not match type.
  # @raise [ValueOutOfBounds] if value is out of bounds for type.
  # @raise [EncodingError] if encoding fails for type.
  # @return [String] the encoded primitive type.
  #
  # source://eth//lib/eth/abi/encoder.rb#97
  def primitive_type(type, arg); end

  # Encodes a specific value, either static or dynamic.
  #
  # @param type [Eth::Abi::Type] type to be encoded.
  # @param arg [String|Number] value to be encoded.
  # @raise [EncodingError] if value does not match type.
  # @return [String] the encoded type.
  #
  # source://eth//lib/eth/abi/encoder.rb#33
  def type(type, arg); end

  private

  # Properly encodes addresses.
  #
  # source://eth//lib/eth/abi/encoder.rb#259
  def address(arg); end

  # Properly encodes booleans.
  #
  # @raise [EncodingError]
  #
  # source://eth//lib/eth/abi/encoder.rb#145
  def bool(arg); end

  # Properly encodes byte-strings.
  #
  # @raise [EncodingError]
  #
  # source://eth//lib/eth/abi/encoder.rb#168
  def bytes(arg, type); end

  # Properly encodes signed fixed-point numbers.
  #
  # @raise [ArgumentError]
  #
  # source://eth//lib/eth/abi/encoder.rb#159
  def fixed(arg, type); end

  # The ABI encoder needs to be able to determine between a hex `"123"`
  # and a binary `"123"` string.
  #
  # source://eth//lib/eth/abi/encoder.rb#287
  def handle_hex_string(arg, type); end

  # Properly encodes hash-strings.
  #
  # @raise [EncodingError]
  #
  # source://eth//lib/eth/abi/encoder.rb#238
  def hash(arg, type); end

  # Properly encodes signed integers.
  #
  # @raise [ArgumentError]
  #
  # source://eth//lib/eth/abi/encoder.rb#135
  def int(arg, type); end

  # Properly encode struct offsets.
  #
  # source://eth//lib/eth/abi/encoder.rb#221
  def struct_offsets(type, arg); end

  # Properly encodes tuples.
  #
  # @raise [EncodingError]
  #
  # source://eth//lib/eth/abi/encoder.rb#188
  def tuple(arg, type); end

  # Properly encodes unsigned fixed-point numbers.
  #
  # @raise [ArgumentError]
  #
  # source://eth//lib/eth/abi/encoder.rb#151
  def ufixed(arg, type); end

  # Properly encodes unsigned integers.
  #
  # @raise [ArgumentError]
  #
  # source://eth//lib/eth/abi/encoder.rb#125
  def uint(arg, type); end
end

# Provides a special encoding error if anything fails to encode.
#
# source://eth//lib/eth/abi.rb#28
class Eth::Abi::EncodingError < ::StandardError; end

# Provides a module to decode transaction log events.
#
# source://eth//lib/eth/abi/event.rb#24
module Eth::Abi::Event
  extend ::Eth::Abi::Event

  # Compute topic for ABI event interface.
  #
  # @param interface [Hash] ABI event interface.
  # @return [String] a hex-string topic.
  #
  # source://eth//lib/eth/abi/event.rb#31
  def compute_topic(interface); end

  # Decodes event log argument values.
  #
  # @param inputs [Array] event ABI types.
  # @param data [String] ABI event data to be decoded.
  # @param topics [Array] ABI event topics to be decoded.
  # @param anonymous [Boolean] If event signature is excluded from topics.
  # @raise [DecodingError] if decoding fails for type.
  # @return [[Array, Hash]] decoded positional arguments and decoded keyword arguments.
  #
  # source://eth//lib/eth/abi/event.rb#126
  def decode_log(inputs, data, topics, anonymous = T.unsafe(nil)); end

  # Decodes a stream of receipt logs with a set of ABI interfaces.
  #
  # @param interfaces [Array] event ABI types.
  # @param logs [Array] transaction receipt logs
  # @return [Hash] an enumerator of LogDescription objects.
  #
  # source://eth//lib/eth/abi/event.rb#103
  def decode_logs(interfaces, logs); end

  # Build event signature string from ABI interface.
  #
  # @param interface [Hash] ABI event interface.
  # @return [String] interface signature string.
  #
  # source://eth//lib/eth/abi/event.rb#40
  def signature(interface); end

  # source://eth//lib/eth/abi/event.rb#47
  def type(input); end
end

# A decoded event log.
#
# source://eth//lib/eth/abi/event.rb#58
class Eth::Abi::Event::LogDescription
  # Decodes event log argument values.
  #
  # @param event_interface [Hash] event ABI type.
  # @param log [Hash] transaction receipt log
  # @return [LogDescription] a new instance of LogDescription
  #
  # source://eth//lib/eth/abi/event.rb#75
  def initialize(event_interface, log); end

  # The the input argument of the event.
  #
  # source://eth//lib/eth/abi/event.rb#63
  def args; end

  # The the input argument of the event.
  #
  # source://eth//lib/eth/abi/event.rb#63
  def args=(_arg0); end

  # The event ABI interface used to decode the log.
  #
  # source://eth//lib/eth/abi/event.rb#60
  def event_interface; end

  # The event ABI interface used to decode the log.
  #
  # source://eth//lib/eth/abi/event.rb#60
  def event_interface=(_arg0); end

  # The named input argument of the event.
  #
  # source://eth//lib/eth/abi/event.rb#66
  def kwargs; end

  # The named input argument of the event.
  #
  # source://eth//lib/eth/abi/event.rb#66
  def kwargs=(_arg0); end

  # The event name. (e.g. Transfer)
  #
  # source://eth//lib/eth/abi/event.rb#88
  def name; end

  # The event signature. (e.g. Transfer(address,address,uint256))
  #
  # source://eth//lib/eth/abi/event.rb#93
  def signature; end

  # The topic hash.
  #
  # source://eth//lib/eth/abi/event.rb#69
  def topic; end

  # The topic hash.
  #
  # source://eth//lib/eth/abi/event.rb#69
  def topic=(_arg0); end
end

# Provides a class to handle and parse common ABI types.
#
# source://eth//lib/eth/abi/type.rb#24
class Eth::Abi::Type
  extend ::Konstructor::SimpleMethodHook

  # Create a new Type object for base types, sub types, and dimensions.
  # Should not be used; use {Type.parse} instead.
  #
  # @param base_type [String] the base-type attribute.
  # @param sub_type [String] the sub-type attribute.
  # @param dimensions [Array] the dimension attribute.
  # @param components [Array] the components attribute.
  # @param component_name [String] the tuple component's name.
  # @return [Eth::Abi::Type] an ABI type object.
  #
  # source://eth//lib/eth/abi/type.rb#53
  def initialize(base_type, sub_type, dimensions, components = T.unsafe(nil), component_name = T.unsafe(nil)); end

  # Compares two types for their attributes.
  #
  # @param another_type [Eth::Abi::Type] another type to be compared.
  # @return [Boolean] true if all attributes match.
  #
  # source://eth//lib/eth/abi/type.rb#112
  def ==(another_type); end

  # The base attribute, e.g., `string` or `bytes`.
  #
  # source://eth//lib/eth/abi/type.rb#30
  def base_type; end

  # The components of a tuple type.
  #
  # source://eth//lib/eth/abi/type.rb#39
  def components; end

  # The dimension attribute, e.g., `[10]` for an array of size 10.
  #
  # source://eth//lib/eth/abi/type.rb#36
  def dimensions; end

  # Helpes to determine whether array is of dynamic size.
  #
  # @return [Boolean] true if array is of dynamic size.
  #
  # source://eth//lib/eth/abi/type.rb#138
  def dynamic?; end

  # The name of tuple component.
  #
  # source://eth//lib/eth/abi/type.rb#42
  def name; end

  # Types can have nested sub-types in arrays.
  #
  # @return [Eth::Abi::Type] nested sub-type.
  #
  # source://eth//lib/eth/abi/type.rb#145
  def nested_sub; end

  # Computes the size of a type if possible.
  #
  # @return [Integer] the size of the type; or nil if not available.
  #
  # source://eth//lib/eth/abi/type.rb#121
  def size; end

  # The sub-type attribute, e.g., `256` as size of an uint256.
  #
  # source://eth//lib/eth/abi/type.rb#33
  def sub_type; end

  # Allows exporting the type as string.
  #
  # @return [String] the type string.
  #
  # source://eth//lib/eth/abi/type.rb#152
  def to_s; end

  private

  # Attempts to parse a string containing a common Solidity type.
  # Creates a new Type upon success (using konstructor).
  #
  # @param type [String] a common Solidity type.
  # @param components [Array] the components attribute.
  # @param component_name [String] the tuple component's name.
  # @raise [ParseError] if it fails to parse the type.
  # @return [Eth::Abi::Type] a parsed Type object.
  #
  # source://eth//lib/eth/abi/type.rb#73
  def parse(type, components = T.unsafe(nil), component_name = T.unsafe(nil)); end

  # Validates all known base types and raises if an issue occurs.
  #
  # source://eth//lib/eth/abi/type.rb#169
  def validate_base_type(base_type, sub_type); end

  class << self
    # source://konstructor/1.0.2/lib/konstructor/factory.rb#118
    def parse(*args, &block); end

    # Creates a new uint256 type used for size.
    #
    # @return [Eth::Abi::Type] a uint256 size type.
    #
    # source://eth//lib/eth/abi/type.rb#104
    def size_type; end
  end
end

# Provides a specific parser error if type cannot be determined.
#
# source://eth//lib/eth/abi/type.rb#27
class Eth::Abi::Type::ParseError < ::StandardError; end

# Provides a special out-of-bounds error for values.
#
# source://eth//lib/eth/abi.rb#34
class Eth::Abi::ValueOutOfBounds < ::StandardError; end

# The {Eth::Address} class to handle checksummed Ethereum addresses.
#
# source://eth//lib/eth/address.rb#19
class Eth::Address
  # Constructor of the {Eth::Address} class. Creates a new hex
  # prefixed address.
  #
  # @param address [String] hex string representing an ethereum address.
  # @return [Address] a new instance of Address
  #
  # source://eth//lib/eth/address.rb#31
  def initialize(address); end

  # The prefixed and checksummed Ethereum address.
  #
  # source://eth//lib/eth/address.rb#25
  def address; end

  # Generate a checksummed address.
  #
  # @raise [CheckSumError]
  # @return [String] prefixed hexstring representing an checksummed address.
  #
  # source://eth//lib/eth/address.rb#57
  def checksummed; end

  # Generate a checksummed address.
  #
  # @raise [CheckSumError]
  # @return [String] prefixed hexstring representing an checksummed address.
  #
  # source://eth//lib/eth/address.rb#57
  def to_s; end

  # Checks that the address is valid.
  #
  # @return [Boolean] true if valid address.
  #
  # source://eth//lib/eth/address.rb#44
  def valid?; end

  private

  # Checks whether the address is all lower-case.
  #
  # @return [Boolean]
  #
  # source://eth//lib/eth/address.rb#87
  def all_lowercase?; end

  # Checks whether the address is all upper-case.
  #
  # @return [Boolean]
  #
  # source://eth//lib/eth/address.rb#82
  def all_uppercase?; end

  # Computes the checksum of the address.
  #
  # source://eth//lib/eth/address.rb#97
  def checksum; end

  # Checks whether the address checksum matches.
  #
  # @return [Boolean]
  #
  # source://eth//lib/eth/address.rb#72
  def checksum_matches?; end

  # Checks whether the address matches any known format.
  #
  # @return [Boolean]
  #
  # source://eth//lib/eth/address.rb#92
  def matches_any_format?; end

  # Checks whether the address is not checksummed.
  #
  # @return [Boolean]
  #
  # source://eth//lib/eth/address.rb#77
  def not_checksummed?; end

  # Removes the hex prefix.
  #
  # source://eth//lib/eth/address.rb#102
  def unprefixed; end
end

# Provides a special checksum error if EIP-55 is violated.
#
# source://eth//lib/eth/address.rb#22
class Eth::Address::CheckSumError < ::StandardError; end

# Provides the `Eth::Api` module grouping known RPC commands.
#
# source://eth//lib/eth/api.rb#19
module Eth::Api; end

# Implements the available RPC-APIs provided by Geth version 1.10.26.
#
# source://eth//lib/eth/api.rb#22
Eth::Api::COMMANDS = T.let(T.unsafe(nil), Array)

# Encapsulates {Eth::Chain} IDs and utilities for EIP-155 compatibility.
# Ref: https://eips.ethereum.org/EIPS/eip-155
#
# source://eth//lib/eth/chain.rb#20
module Eth::Chain
  extend ::Eth::Chain

  # Indicates wether the given `v` indicates a legacy chain value
  # used by ledger wallets without EIP-155 replay protection.
  #
  # @param v [Integer] the signature's `v` value.
  # @return [Boolean] true if ledger's legacy value.
  #
  # source://eth//lib/eth/chain.rb#121
  def ledger?(v); end

  # Indicates wether the given `v` indicates a legacy chain value
  # without EIP-155 replay protection.
  #
  # @param v [Integer] the signature's `v` value.
  # @return [Boolean] true if legacy value.
  #
  # source://eth//lib/eth/chain.rb#130
  def legacy?(v); end

  # Converts a `v` value into a chain ID. This does not work for legacy signatures
  # with `v < 36` that do not conform with EIP-155.
  #
  # @param v [Integer] the signature's `v` value.
  # @return [Integer] the chain id as per EIP-155 or `nil` if there is no replay protection.
  #
  # source://eth//lib/eth/chain.rb#180
  def to_chain_id(v); end

  # Convert a given `v` value to an ECDSA recovery id for the given
  # EIP-155 chain ID.
  #
  # @param v [Integer] the signature's `v` value.
  # @param chain_id [Integer] the chain id the signature was generated on.
  # @raise [ReplayProtectionError] if the given `v` is invalid.
  # @return [Integer] the recovery id corresponding to `v`.
  #
  # source://eth//lib/eth/chain.rb#141
  def to_recovery_id(v, chain_id = T.unsafe(nil)); end

  # Converts a recovery ID into the expected `v` on a given chain.
  #
  # @param recovery_id [Integer] signature recovery id.
  # @param chain_id [Integer] the chain id the signature was generated on.
  # @return [Integer] the signature's `v` value.
  #
  # source://eth//lib/eth/chain.rb#166
  def to_v(recovery_id, chain_id = T.unsafe(nil)); end
end

# Chain ID for Arbitrum mainnet.
#
# source://eth//lib/eth/chain.rb#54
Eth::Chain::ARBITRUM = T.let(T.unsafe(nil), Integer)

# Chain ID for Ethereum Classic mainnet.
#
# source://eth//lib/eth/chain.rb#36
Eth::Chain::CLASSIC = T.let(T.unsafe(nil), Integer)

# Chain ID for Ethereum mainnet.
#
# source://eth//lib/eth/chain.rb#27
Eth::Chain::ETHEREUM = T.let(T.unsafe(nil), Integer)

# Chain ID for Expanse mainnet.
#
# source://eth//lib/eth/chain.rb#30
Eth::Chain::EXPANSE = T.let(T.unsafe(nil), Integer)

# Chain ID for Gnosis mainnet (formerly xDAI).
#
# source://eth//lib/eth/chain.rb#45
Eth::Chain::GNOSIS = T.let(T.unsafe(nil), Integer)

# Chain ID for Goerli testnet.
#
# source://eth//lib/eth/chain.rb#66
Eth::Chain::GOERLI = T.let(T.unsafe(nil), Integer)

# Chain ID for Arbitrum Goerli testnet.
#
# source://eth//lib/eth/chain.rb#96
Eth::Chain::GOERLI_ARBITRUM = T.let(T.unsafe(nil), Integer)

# Chain ID for Optimistic Goerli testnet.
#
# source://eth//lib/eth/chain.rb#87
Eth::Chain::GOERLI_OPTIMISM = T.let(T.unsafe(nil), Integer)

# Chain ID for Holesovice testnet.
#
# source://eth//lib/eth/chain.rb#102
Eth::Chain::HOLESOVICE = T.let(T.unsafe(nil), Integer)

# Chain ID for Kotti testnet.
#
# source://eth//lib/eth/chain.rb#69
Eth::Chain::KOTTI = T.let(T.unsafe(nil), Integer)

# Chain ID for Kovan testnet.
#
# source://eth//lib/eth/chain.rb#72
Eth::Chain::KOVAN = T.let(T.unsafe(nil), Integer)

# Chain ID for Optimistik Kovan testnet.
#
# source://eth//lib/eth/chain.rb#81
Eth::Chain::KOVAN_OPTIMISM = T.let(T.unsafe(nil), Integer)

# Chain ID for the Matic mainnet (now Polygon).
#
# source://eth//lib/eth/chain.rb#48
Eth::Chain::MATIC = T.let(T.unsafe(nil), Integer)

# Chain ID for Moonbase
#
# source://eth//lib/eth/chain.rb#108
Eth::Chain::MOONBASE = T.let(T.unsafe(nil), Integer)

# Chain ID for Moonbeam
#
# source://eth//lib/eth/chain.rb#114
Eth::Chain::MOONBEAM = T.let(T.unsafe(nil), Integer)

# Chain ID for Moonriver
#
# source://eth//lib/eth/chain.rb#111
Eth::Chain::MOONRIVER = T.let(T.unsafe(nil), Integer)

# Chain ID for Morden (Ethereum) testnet.
#
# source://eth//lib/eth/chain.rb#57
Eth::Chain::MORDEN = T.let(T.unsafe(nil), Integer)

# Chain ID for Morden (Classic) testnet.
#
# source://eth//lib/eth/chain.rb#75
Eth::Chain::MORDEN_CLASSIC = T.let(T.unsafe(nil), Integer)

# Chain ID for Mordor testnet.
#
# source://eth//lib/eth/chain.rb#78
Eth::Chain::MORDOR = T.let(T.unsafe(nil), Integer)

# Chain ID for the Polygon Mumbai testnet.
#
# source://eth//lib/eth/chain.rb#90
Eth::Chain::MUMBAI = T.let(T.unsafe(nil), Integer)

# Chain ID for Optimistic Ethereum mainnet.
#
# source://eth//lib/eth/chain.rb#33
Eth::Chain::OPTIMISM = T.let(T.unsafe(nil), Integer)

# Chain ID for POA Network mainnet.
#
# source://eth//lib/eth/chain.rb#39
Eth::Chain::POA_NET = T.let(T.unsafe(nil), Integer)

# Chain ID for the Polygon mainnet (formerly Matic).
#
# source://eth//lib/eth/chain.rb#51
Eth::Chain::POLYGON = T.let(T.unsafe(nil), Integer)

# Chain ID for the geth private network preset.
#
# source://eth//lib/eth/chain.rb#105
Eth::Chain::PRIVATE_GETH = T.let(T.unsafe(nil), Integer)

# Chain ID for Rinkeby testnet.
#
# source://eth//lib/eth/chain.rb#63
Eth::Chain::RINKEBY = T.let(T.unsafe(nil), Integer)

# Chain ID for Arbitrum Rinkeby testnet.
#
# source://eth//lib/eth/chain.rb#93
Eth::Chain::RINKEBY_ARBITRUM = T.let(T.unsafe(nil), Integer)

# Chain ID for Ropsten testnet.
#
# source://eth//lib/eth/chain.rb#60
Eth::Chain::ROPSTEN = T.let(T.unsafe(nil), Integer)

# Provides a special replay protection error if EIP-155 is violated.
#
# source://eth//lib/eth/chain.rb#24
class Eth::Chain::ReplayProtectionError < ::StandardError; end

# Chain ID for Sepolia testnet.
#
# source://eth//lib/eth/chain.rb#99
Eth::Chain::SEPOLIA = T.let(T.unsafe(nil), Integer)

# Chain ID for xDAI mainnet (now Gnosis Chain).
#
# source://eth//lib/eth/chain.rb#42
Eth::Chain::XDAI = T.let(T.unsafe(nil), Integer)

# Chain ID for Arbitrum xDAI testnet.
#
# source://eth//lib/eth/chain.rb#84
Eth::Chain::XDAI_ARBITRUM = T.let(T.unsafe(nil), Integer)

# Provides the {Eth::Client} super-class to connect to Ethereum
# network's RPC-API endpoints (IPC or HTTP).
#
# source://eth//lib/eth/client.rb#20
class Eth::Client
  # Constructor for the {Eth::Client} super-class. Should not be used;
  # use {Client.create} intead.
  #
  # @return [Client] a new instance of Client
  #
  # source://eth//lib/eth/client.rb#62
  def initialize(_); end

  # source://eth//lib/eth/client.rb#393
  def account_ec_recover(*args); end

  # source://eth//lib/eth/client.rb#393
  def account_new(*args); end

  # source://eth//lib/eth/client.rb#393
  def account_sign_data(*args); end

  # source://eth//lib/eth/client.rb#393
  def account_sign_transaction(*args); end

  # source://eth//lib/eth/client.rb#393
  def account_sign_typed_data(*args); end

  # source://eth//lib/eth/client.rb#393
  def admin_add_peer(*args); end

  # source://eth//lib/eth/client.rb#393
  def admin_add_trusted_peer(*args); end

  # source://eth//lib/eth/client.rb#393
  def admin_datadir(*args); end

  # source://eth//lib/eth/client.rb#393
  def admin_export_chain(*args); end

  # source://eth//lib/eth/client.rb#393
  def admin_import_chain(*args); end

  # source://eth//lib/eth/client.rb#393
  def admin_node_info(*args); end

  # source://eth//lib/eth/client.rb#393
  def admin_peer_events(*args); end

  # source://eth//lib/eth/client.rb#393
  def admin_peers(*args); end

  # source://eth//lib/eth/client.rb#393
  def admin_remove_peer(*args); end

  # source://eth//lib/eth/client.rb#393
  def admin_remove_trusted_peer(*args); end

  # source://eth//lib/eth/client.rb#393
  def admin_start_http(*args); end

  # source://eth//lib/eth/client.rb#393
  def admin_start_ws(*args); end

  # source://eth//lib/eth/client.rb#393
  def admin_stop_http(*args); end

  # source://eth//lib/eth/client.rb#393
  def admin_stop_ws(*args); end

  # The block number used for archive calls.
  #
  # source://eth//lib/eth/client.rb#38
  def block_number; end

  # The block number used for archive calls.
  #
  # source://eth//lib/eth/client.rb#38
  def block_number=(_arg0); end

  # Calls a contract function without executing it
  # (non-transactional contract read).
  #
  # @overload call
  # @overload call
  # @overload call
  # @raise [ArgumentError]
  # @return [Object] returns the result of the call.
  #
  # source://eth//lib/eth/client.rb#254
  def call(contract, function, *args, **kwargs); end

  # Gets the chain ID of the connected network.
  #
  # @return [Integer] the chain ID.
  #
  # source://eth//lib/eth/client.rb#82
  def chain_id; end

  # source://eth//lib/eth/client.rb#393
  def clef_derive_account(*args); end

  # source://eth//lib/eth/client.rb#393
  def clef_list_wallets(*args); end

  # source://eth//lib/eth/client.rb#393
  def clef_open_wallet(*args); end

  # source://eth//lib/eth/client.rb#393
  def clique_discard(*args); end

  # source://eth//lib/eth/client.rb#393
  def clique_get_signer(*args); end

  # source://eth//lib/eth/client.rb#393
  def clique_get_signers(*args); end

  # source://eth//lib/eth/client.rb#393
  def clique_get_signers_at_hash(*args); end

  # source://eth//lib/eth/client.rb#393
  def clique_get_snapshot(*args); end

  # source://eth//lib/eth/client.rb#393
  def clique_get_snapshot_at_hash(*args); end

  # source://eth//lib/eth/client.rb#393
  def clique_proposals(*args); end

  # source://eth//lib/eth/client.rb#393
  def clique_propose(*args); end

  # source://eth//lib/eth/client.rb#393
  def clique_status(*args); end

  # source://eth//lib/eth/client.rb#393
  def db_get_hex(*args); end

  # source://eth//lib/eth/client.rb#393
  def db_get_string(*args); end

  # source://eth//lib/eth/client.rb#393
  def db_put_hex(*args); end

  # source://eth//lib/eth/client.rb#393
  def db_put_string(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_account_range(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_backtrace_at(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_block_profile(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_chaindb_compact(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_chaindb_property(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_cpu_profile(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_db_ancient(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_db_ancients(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_db_get(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_dump_block(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_free_osmemory(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_freeze_client(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_gc_stats(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_get_accessible_state(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_get_bad_blocks(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_get_block_rlp(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_get_header_rlp(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_get_modified_accounts_by_hash(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_get_modified_accounts_by_number(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_get_raw_block(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_get_raw_header(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_get_raw_receipts(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_get_raw_transaction(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_go_trace(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_intermediate_roots(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_mem_stats(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_mutex_profile(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_preimage(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_print_block(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_seed_hash(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_set_block_profile_rate(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_set_gcpercent(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_set_head(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_set_mutex_profile_fraction(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_stacks(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_standard_trace_bad_block_to_file(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_standard_trace_block_to_file(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_start_cpuprofile(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_start_go_trace(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_stop_cpuprofile(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_stop_go_trace(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_storage_range_at(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_subscribe(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_trace_bad_block(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_trace_block(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_trace_block_by_hash(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_trace_block_by_number(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_trace_block_from_file(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_trace_call(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_trace_chain(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_trace_transaction(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_verbosity(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_vmodule(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_write_block_profile(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_write_mem_profile(*args); end

  # source://eth//lib/eth/client.rb#393
  def debug_write_mutex_profile(*args); end

  # Gets the default account (first account) of the connected client.
  #
  # **Note**, that many remote providers (e.g., Infura) do not provide
  # any accounts.
  #
  # @raise [ArgumentError]
  # @return [Eth::Address] the default account address.
  #
  # source://eth//lib/eth/client.rb#74
  def default_account; end

  # The connected network's client default account.
  #
  # source://eth//lib/eth/client.rb#29
  def default_account=(_arg0); end

  # Deploys a contract. Uses `eth_accounts` or external signer
  # if no sender key is provided.
  #
  # **Note**, that many remote providers (e.g., Infura) do not provide
  # any accounts. Provide a `sender_key:` if you experience issues.
  #
  # @overload deploy
  # @overload deploy
  # @overload deploy
  # @raise [ArgumentError] in case the contract does not have any source.
  # @return [String] the transaction hash.
  #
  # source://eth//lib/eth/client.rb#216
  def deploy(contract, *args, **kwargs); end

  # Deploys a contract and waits for it to be mined. Uses
  # `eth_accounts` or external signer if no sender key is provided.
  #
  # See {#deploy} for params and overloads.
  #
  # @return [String] the contract address once it's mined.
  #
  # source://eth//lib/eth/client.rb#190
  def deploy_and_wait(contract, *args, **kwargs); end

  # source://eth//lib/eth/client.rb#393
  def eth_accounts(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_block_number(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_call(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_chain_id(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_compile_lll(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_compile_serpent(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_compile_solidity(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_create_access_list(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_estimate_gas(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_fee_history(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_gas_price(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_balance(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_block_by_hash(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_block_by_number(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_block_transaction_count_by_hash(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_block_transaction_count_by_number(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_code(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_compilers(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_filter_changes(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_filter_logs(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_logs(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_proof(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_storage_at(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_transaction_by_block_hash_and_index(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_transaction_by_block_number_and_index(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_transaction_by_hash(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_transaction_count(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_transaction_receipt(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_uncle_by_block_hash_and_index(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_uncle_by_block_number_and_index(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_uncle_count_by_block_hash(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_uncle_count_by_block_number(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_get_work(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_hashrate(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_max_priority_fee_per_gas(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_mining(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_new_block_filter(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_new_filter(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_new_pending_transaction_filter(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_protocol_version(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_send_raw_transaction(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_send_transaction(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_sign(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_sign_transaction(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_submit_hashrate(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_submit_work(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_syncing(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_uninstall_filter(*args); end

  # source://eth//lib/eth/client.rb#393
  def eth_unsubscribe(*args); end

  # Gets the balance for an address.
  #
  # @param address [Eth::Address] the address to get the balance for.
  # @return [Integer] the balance in Wei.
  #
  # source://eth//lib/eth/client.rb#90
  def get_balance(address); end

  # Gets the next nonce for an address used to draft new transactions.
  #
  # @param address [Eth::Address] the address to get the nonce for.
  # @return [Integer] the next nonce to be used.
  #
  # source://eth//lib/eth/client.rb#98
  def get_nonce(address); end

  # The client's RPC-request ID starting at 0.
  #
  # source://eth//lib/eth/client.rb#23
  def id; end

  # Provides an interface to call `isValidSignature` as per EIP-1271 on a given
  # smart contract to verify the given hash and signature matching the magic
  # value.
  #
  # @param contract [Eth::Contract] a deployed contract implementing EIP-1271.
  # @param hash [String] the message hash to be checked against the signature.
  # @param signature [String] the signature to be recovered by the contract.
  # @param magic [String] the expected magic value (defaults to `1626ba7e`).
  # @raise [ArgumentError] in case the contract cannot be called yet.
  # @return [Boolean] true if magic matches and signature is valid.
  #
  # source://eth//lib/eth/client.rb#338
  def is_valid_signature(contract, hash, signature, magic = T.unsafe(nil)); end

  # source://eth//lib/eth/client.rb#393
  def les_add_balance(*args); end

  # source://eth//lib/eth/client.rb#393
  def les_client_info(*args); end

  # source://eth//lib/eth/client.rb#393
  def les_get_checkpoint(*args); end

  # source://eth//lib/eth/client.rb#393
  def les_get_checkpoint_contract_address(*args); end

  # source://eth//lib/eth/client.rb#393
  def les_latest_checkpoint(*args); end

  # source://eth//lib/eth/client.rb#393
  def les_priority_client_info(*args); end

  # source://eth//lib/eth/client.rb#393
  def les_server_info(*args); end

  # source://eth//lib/eth/client.rb#393
  def les_set_client_params(*args); end

  # source://eth//lib/eth/client.rb#393
  def les_set_default_params(*args); end

  # The default transaction max fee per gas in Wei, defaults to {Tx::DEFAULT_GAS_PRICE}.
  #
  # source://eth//lib/eth/client.rb#35
  def max_fee_per_gas; end

  # The default transaction max fee per gas in Wei, defaults to {Tx::DEFAULT_GAS_PRICE}.
  #
  # source://eth//lib/eth/client.rb#35
  def max_fee_per_gas=(_arg0); end

  # The default transaction max priority fee per gas in Wei, defaults to {Tx::DEFAULT_PRIORITY_FEE}.
  #
  # source://eth//lib/eth/client.rb#32
  def max_priority_fee_per_gas; end

  # The default transaction max priority fee per gas in Wei, defaults to {Tx::DEFAULT_PRIORITY_FEE}.
  #
  # source://eth//lib/eth/client.rb#32
  def max_priority_fee_per_gas=(_arg0); end

  # source://eth//lib/eth/client.rb#393
  def miner_get_hashrate(*args); end

  # source://eth//lib/eth/client.rb#393
  def miner_set_etherbase(*args); end

  # source://eth//lib/eth/client.rb#393
  def miner_set_extra(*args); end

  # source://eth//lib/eth/client.rb#393
  def miner_set_gas_limit(*args); end

  # source://eth//lib/eth/client.rb#393
  def miner_set_gas_price(*args); end

  # source://eth//lib/eth/client.rb#393
  def miner_set_recommit_interval(*args); end

  # source://eth//lib/eth/client.rb#393
  def miner_start(*args); end

  # source://eth//lib/eth/client.rb#393
  def miner_stop(*args); end

  # source://eth//lib/eth/client.rb#393
  def net_listening(*args); end

  # source://eth//lib/eth/client.rb#393
  def net_peer_count(*args); end

  # source://eth//lib/eth/client.rb#393
  def net_version(*args); end

  # source://eth//lib/eth/client.rb#393
  def personal_derive_account(*args); end

  # source://eth//lib/eth/client.rb#393
  def personal_ec_recover(*args); end

  # source://eth//lib/eth/client.rb#393
  def personal_import_raw_key(*args); end

  # source://eth//lib/eth/client.rb#393
  def personal_initialize_wallet(*args); end

  # source://eth//lib/eth/client.rb#393
  def personal_initialize_wallets(*args); end

  # source://eth//lib/eth/client.rb#393
  def personal_list_accounts(*args); end

  # source://eth//lib/eth/client.rb#393
  def personal_list_wallets(*args); end

  # source://eth//lib/eth/client.rb#393
  def personal_lock_account(*args); end

  # source://eth//lib/eth/client.rb#393
  def personal_new_account(*args); end

  # source://eth//lib/eth/client.rb#393
  def personal_open_wallet(*args); end

  # source://eth//lib/eth/client.rb#393
  def personal_send_transaction(*args); end

  # source://eth//lib/eth/client.rb#393
  def personal_sign(*args); end

  # source://eth//lib/eth/client.rb#393
  def personal_sign_transaction(*args); end

  # source://eth//lib/eth/client.rb#393
  def personal_unlock_account(*args); end

  # source://eth//lib/eth/client.rb#393
  def personal_unpair(*args); end

  # Gives control over resetting the RPC request ID back to zero.
  # Usually not needed.
  #
  # @return [Integer] 0
  #
  # source://eth//lib/eth/client.rb#351
  def reset_id; end

  # Resolves an ENS name to an Ethereum address on the connected chain.
  #
  # @param ens_name [String] The ENS name, e.g., `fancy.eth`.
  # @param registry [String] the address for the ENS registry.
  # @param coin_type [Integer] the coin type as per EIP-2304.
  # @return [Eth::Address] the Ethereum address resolved from the ENS record.
  #
  # source://eth//lib/eth/client.rb#108
  def resolve_ens(ens_name, registry = T.unsafe(nil), coin_type = T.unsafe(nil)); end

  # source://eth//lib/eth/client.rb#393
  def shh_add_to_group(*args); end

  # source://eth//lib/eth/client.rb#393
  def shh_get_filter_changes(*args); end

  # source://eth//lib/eth/client.rb#393
  def shh_get_messages(*args); end

  # source://eth//lib/eth/client.rb#393
  def shh_has_identity(*args); end

  # source://eth//lib/eth/client.rb#393
  def shh_new_filter(*args); end

  # source://eth//lib/eth/client.rb#393
  def shh_new_group(*args); end

  # source://eth//lib/eth/client.rb#393
  def shh_new_identity(*args); end

  # source://eth//lib/eth/client.rb#393
  def shh_post(*args); end

  # source://eth//lib/eth/client.rb#393
  def shh_uninstall_filter(*args); end

  # source://eth//lib/eth/client.rb#393
  def shh_version(*args); end

  # Executes a contract function with a transaction (transactional
  # contract read/write).
  #
  # **Note**, that many remote providers (e.g., Infura) do not provide
  # any accounts. Provide a `sender_key:` if you experience issues.
  #
  # @overload transact
  # @overload transact
  # @overload transact
  # @return [Object] returns the result of the transaction.
  #
  # source://eth//lib/eth/client.rb#295
  def transact(contract, function, *args, **kwargs); end

  # Executes a contract function with a transaction and waits for it
  # to be mined (transactional contract read/write).
  #
  # See {#transact} for params and overloads.
  #
  # @raise [Client::ContractExecutionError] if the execution fails.
  # @return [Object] returns the result of the transaction.
  #
  # source://eth//lib/eth/client.rb#319
  def transact_and_wait(contract, function, *args, **kwargs); end

  # Simply transfer Ether to an account without any call data or
  # access lists attached. Uses `eth_accounts` and external signer
  # if no sender key is provided.
  #
  # **Note**, that many remote providers (e.g., Infura) do not provide
  # any accounts. Provide a `sender_key:` if you experience issues.
  #
  # @overload transfer
  # @overload transfer
  # @return [String] the local transaction hash.
  #
  # source://eth//lib/eth/client.rb#141
  def transfer(destination, amount, **kwargs); end

  # Simply transfer Ether to an account and waits for it to be mined.
  # Uses `eth_accounts` and external signer if no sender key is
  # provided.
  #
  # See {#transfer} for params and overloads.
  #
  # @return [String] the transaction hash once it is mined.
  #
  # source://eth//lib/eth/client.rb#120
  def transfer_and_wait(destination, amount, **kwargs); end

  # Transfers a token that implements the ERC20 `transfer()` interface.
  #
  # **Note**, that many remote providers (e.g., Infura) do not provide
  # any accounts. Provide a `sender_key:` if you experience issues.
  #
  # @overload transfer_erc20
  # @overload transfer_erc20
  # @return [Object] returns the result of the transaction.
  #
  # source://eth//lib/eth/client.rb#179
  def transfer_erc20(erc20_contract, destination, amount, **kwargs); end

  # Transfers a token that implements the ERC20 `transfer()` interface.
  #
  # See {#transfer_erc20} for params and overloads.
  #
  # @return [Object] returns the result of the transaction.
  #
  # source://eth//lib/eth/client.rb#156
  def transfer_erc20_and_wait(erc20_contract, destination, amount, **kwargs); end

  # Checks whether a transaction is mined or not.
  #
  # @param hash [String] the transaction hash.
  # @return [Boolean] true if included in a block.
  #
  # source://eth//lib/eth/client.rb#359
  def tx_mined?(hash); end

  # Checks whether a contract transaction succeeded or not.
  #
  # @param hash [String] the transaction hash.
  # @return [Boolean] true if status is success.
  #
  # source://eth//lib/eth/client.rb#368
  def tx_succeeded?(hash); end

  # source://eth//lib/eth/client.rb#393
  def txpool_content(*args); end

  # source://eth//lib/eth/client.rb#393
  def txpool_content_from(*args); end

  # source://eth//lib/eth/client.rb#393
  def txpool_inspect(*args); end

  # source://eth//lib/eth/client.rb#393
  def txpool_status(*args); end

  # Waits for an transaction to be mined by the connected chain.
  #
  # @param hash [String] the transaction hash.
  # @raise [Timeout::Error] if it's not mined within 5 minutes.
  # @return [String] the transaction hash once the transaction is mined.
  #
  # source://eth//lib/eth/client.rb#378
  def wait_for_tx(hash); end

  # source://eth//lib/eth/client.rb#393
  def web3_client_version(*args); end

  # source://eth//lib/eth/client.rb#393
  def web3_sha3(*args); end

  private

  # Encodes function call payloads.
  #
  # source://eth//lib/eth/client.rb#461
  def call_payload(fun, args); end

  # Non-transactional function call called from call().
  #
  # @see https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call
  #
  # source://eth//lib/eth/client.rb#447
  def call_raw(contract, func, *args, **kwargs); end

  # expects Hash object
  #
  # source://eth//lib/eth/client.rb#494
  def camelize!(params); end

  # Encodes constructor params
  #
  # source://eth//lib/eth/client.rb#468
  def encode_constructor_params(contract, args); end

  # Allows to determine if we work with a local connectoin
  #
  # @return [Boolean]
  #
  # source://eth//lib/eth/client.rb#401
  def local?; end

  # Recursively marshals all request parameters.
  #
  # source://eth//lib/eth/client.rb#503
  def marshal(params); end

  # Increments the request id.
  #
  # source://eth//lib/eth/client.rb#489
  def next_id; end

  # Prepares parameters and sends the command to the client.
  #
  # @raise [IOError]
  #
  # source://eth//lib/eth/client.rb#474
  def send_command(command, args); end

  # Prepares a transaction to be send for the given params.
  #
  # source://eth//lib/eth/client.rb#412
  def send_transaction(params, legacy, key, nonce); end

  class << self
    # Creates a new RPC-Client, either by providing an HTTP/S host or
    # an IPC path. Supports basic authentication with username and password.
    #
    # **Note**, this sets the folling gas defaults: {Tx::DEFAULT_PRIORITY_FEE}
    # and {Tx::DEFAULT_GAS_PRICE. Use {#max_priority_fee_per_gas} and
    # {#max_fee_per_gas} to set custom values prior to submitting transactions.
    #
    # @param host [String] either an HTTP/S host or an IPC path.
    # @raise [ArgumentError] in case it cannot determine the client type.
    # @return [Eth::Client::Ipc] an IPC client.
    # @return [Eth::Client::Http] an HTTP client.
    #
    # source://eth//lib/eth/client.rb#54
    def create(host); end
  end
end

# A custom error type if a contract interaction fails.
#
# source://eth//lib/eth/client.rb#41
class Eth::Client::ContractExecutionError < ::StandardError; end

# source://eth//lib/eth/client/http.rb#21
class Eth::Client::Http < ::Eth::Client
  # source://eth//lib/eth/client/http.rb#42
  def initialize(host); end

  # source://eth//lib/eth/client/http.rb#24
  def host; end

  # source://eth//lib/eth/client/http.rb#27
  def port; end

  # source://eth//lib/eth/client/http.rb#62
  def send_request(payload); end

  # source://eth//lib/eth/client/http.rb#33
  def ssl; end

  # source://eth//lib/eth/client/http.rb#30
  def uri; end

  # source://eth//lib/eth/client/http.rb#36
  def user; end
end

# source://eth//lib/eth/client/ipc.rb#21
class Eth::Client::Ipc < ::Eth::Client
  # source://eth//lib/eth/client/ipc.rb#30
  def initialize(path); end

  # source://eth//lib/eth/client/ipc.rb#24
  def path; end

  # source://eth//lib/eth/client/ipc.rb#24
  def path=(_arg0); end

  # source://eth//lib/eth/client/ipc.rb#39
  def send_request(payload); end
end

# Provides commonly used constants, such as zero bytes or zero keys.
#
# source://eth//lib/eth/constant.rb#21
module Eth::Constant; end

# The binary encoding is ASCII (8-bit).
#
# source://eth//lib/eth/constant.rb#66
Eth::Constant::BINARY_ENCODING = T.let(T.unsafe(nil), String)

# The empty byte is defined as "".
#
# source://eth//lib/eth/constant.rb#24
Eth::Constant::BYTE_EMPTY = T.let(T.unsafe(nil), String)

# The byte one is 0x01.
#
# source://eth//lib/eth/constant.rb#30
Eth::Constant::BYTE_ONE = T.let(T.unsafe(nil), String)

# The zero byte is 0x00.
#
# source://eth//lib/eth/constant.rb#27
Eth::Constant::BYTE_ZERO = T.let(T.unsafe(nil), String)

# A hash containing only zeros.
#
# source://eth//lib/eth/constant.rb#51
Eth::Constant::HASH_ZERO = T.let(T.unsafe(nil), String)

# Infinity as constant for convenience.
#
# source://eth//lib/eth/constant.rb#69
Eth::Constant::INFINITY = T.let(T.unsafe(nil), Float)

# The maximum possible value of an Int256.
#
# source://eth//lib/eth/constant.rb#45
Eth::Constant::INT_MAX = T.let(T.unsafe(nil), Integer)

# The minimum possible value of an Int256.
#
# source://eth//lib/eth/constant.rb#48
Eth::Constant::INT_MIN = T.let(T.unsafe(nil), Integer)

# The RLP array type offset.
#
# source://eth//lib/eth/constant.rb#63
Eth::Constant::LIST_PREFIX_OFFSET = T.let(T.unsafe(nil), Integer)

# The RLP long length limit.
#
# source://eth//lib/eth/constant.rb#57
Eth::Constant::LONG_LENGTH_LIMIT = T.let(T.unsafe(nil), Integer)

# The RLP primitive type offset.
#
# source://eth//lib/eth/constant.rb#60
Eth::Constant::PRIMITIVE_PREFIX_OFFSET = T.let(T.unsafe(nil), Integer)

# The RLP short length limit.
#
# source://eth//lib/eth/constant.rb#54
Eth::Constant::SHORT_LENGTH_LIMIT = T.let(T.unsafe(nil), Integer)

# The size of a 256-bit number.
#
# source://eth//lib/eth/constant.rb#36
Eth::Constant::TT256 = T.let(T.unsafe(nil), Integer)

# The size of a 32-bit number.
#
# source://eth//lib/eth/constant.rb#33
Eth::Constant::TT32 = T.let(T.unsafe(nil), Integer)

# The maximum possible value of an UInt256.
#
# source://eth//lib/eth/constant.rb#39
Eth::Constant::UINT_MAX = T.let(T.unsafe(nil), Integer)

# The minimum possible value of an UInt256.
#
# source://eth//lib/eth/constant.rb#42
Eth::Constant::UINT_MIN = T.let(T.unsafe(nil), Integer)

# Provides classes to access smart contracts
#
# source://eth//lib/eth/contract.rb#23
class Eth::Contract
  # Constructor of the {Eth::Contract} class.
  #
  # **Note**, do not use this directly. Use
  # {from_abi}, {from_bin}, or {from_file}!
  #
  # @param name [String] contract name.
  # @param bin [String] contract bin string.
  # @param abi [String] contract abi string.
  # @return [Contract] a new instance of Contract
  #
  # source://eth//lib/eth/contract.rb#38
  def initialize(name, bin, abi); end

  # Returns the value of attribute abi.
  #
  # source://eth//lib/eth/contract.rb#27
  def abi; end

  # Sets the attribute abi
  #
  # @param value the value to set the attribute abi to.
  #
  # source://eth//lib/eth/contract.rb#27
  def abi=(_arg0); end

  # Returns the value of attribute address.
  #
  # source://eth//lib/eth/contract.rb#24
  def address; end

  # Sets the address of the smart contract.
  #
  # @param addr [String|Eth::Address] contract address string.
  #
  # source://eth//lib/eth/contract.rb#98
  def address=(addr); end

  # Returns the value of attribute bin.
  #
  # source://eth//lib/eth/contract.rb#27
  def bin; end

  # Sets the attribute bin
  #
  # @param value the value to set the attribute bin to.
  #
  # source://eth//lib/eth/contract.rb#27
  def bin=(_arg0); end

  # Create meta classes for smart contracts.
  #
  # source://eth//lib/eth/contract.rb#110
  def build; end

  # Returns the value of attribute class_object.
  #
  # source://eth//lib/eth/contract.rb#27
  def class_object; end

  # Sets the attribute class_object
  #
  # @param value the value to set the attribute class_object to.
  #
  # source://eth//lib/eth/contract.rb#27
  def class_object=(_arg0); end

  # Returns the value of attribute constructor_inputs.
  #
  # source://eth//lib/eth/contract.rb#28
  def constructor_inputs; end

  # Sets the attribute constructor_inputs
  #
  # @param value the value to set the attribute constructor_inputs to.
  #
  # source://eth//lib/eth/contract.rb#28
  def constructor_inputs=(_arg0); end

  # Returns the value of attribute events.
  #
  # source://eth//lib/eth/contract.rb#28
  def events; end

  # Sets the attribute events
  #
  # @param value the value to set the attribute events to.
  #
  # source://eth//lib/eth/contract.rb#28
  def events=(_arg0); end

  # Returns the value of attribute functions.
  #
  # source://eth//lib/eth/contract.rb#28
  def functions; end

  # Sets the attribute functions
  #
  # @param value the value to set the attribute functions to.
  #
  # source://eth//lib/eth/contract.rb#28
  def functions=(_arg0); end

  # Returns the value of attribute gas_limit.
  #
  # source://eth//lib/eth/contract.rb#26
  def gas_limit; end

  # Sets the attribute gas_limit
  #
  # @param value the value to set the attribute gas_limit to.
  #
  # source://eth//lib/eth/contract.rb#26
  def gas_limit=(_arg0); end

  # Returns the value of attribute gas_price.
  #
  # source://eth//lib/eth/contract.rb#26
  def gas_price; end

  # Sets the attribute gas_price
  #
  # @param value the value to set the attribute gas_price to.
  #
  # source://eth//lib/eth/contract.rb#26
  def gas_price=(_arg0); end

  # Returns the value of attribute key.
  #
  # source://eth//lib/eth/contract.rb#25
  def key; end

  # Sets the attribute key
  #
  # @param value the value to set the attribute key to.
  #
  # source://eth//lib/eth/contract.rb#25
  def key=(_arg0); end

  # Returns the value of attribute max_fee_per_gas.
  #
  # source://eth//lib/eth/contract.rb#26
  def max_fee_per_gas; end

  # Sets the attribute max_fee_per_gas
  #
  # @param value the value to set the attribute max_fee_per_gas to.
  #
  # source://eth//lib/eth/contract.rb#26
  def max_fee_per_gas=(_arg0); end

  # Returns the value of attribute max_priority_fee_per_gas.
  #
  # source://eth//lib/eth/contract.rb#26
  def max_priority_fee_per_gas; end

  # Sets the attribute max_priority_fee_per_gas
  #
  # @param value the value to set the attribute max_priority_fee_per_gas to.
  #
  # source://eth//lib/eth/contract.rb#26
  def max_priority_fee_per_gas=(_arg0); end

  # Returns the value of attribute name.
  #
  # source://eth//lib/eth/contract.rb#27
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://eth//lib/eth/contract.rb#27
  def name=(_arg0); end

  # Returns the value of attribute nonce.
  #
  # source://eth//lib/eth/contract.rb#26
  def nonce; end

  # Sets the attribute nonce
  #
  # @param value the value to set the attribute nonce to.
  #
  # source://eth//lib/eth/contract.rb#26
  def nonce=(_arg0); end

  private

  # source://eth//lib/eth/contract.rb#134
  def parse_abi(abi); end

  class << self
    # Creates a contract wrapper from ABI and address.
    #
    # @param abi [String] contract abi string.
    # @param address [String] contract address.
    # @param name [String] name of contract.
    # @raise [JSON::ParserError] if the json format is wrong.
    # @raise [ArgumentError] if ABI, address, or name is missing.
    # @return [Eth::Contract::Object] Returns the class of the smart contract.
    #
    # source://eth//lib/eth/contract.rb#71
    def from_abi(abi:, address:, name:); end

    # Creates a contract wrapper from binary and ABI.
    #
    # @param bin [String] contract bin string.
    # @param abi [String] contract abi string.
    # @param name [String] name of contract.
    # @raise [JSON::ParserError] if the json format is wrong.
    # @raise [ArgumentError] if ABI, binary, or name is missing.
    # @return [Eth::Contract::Object] Returns the class of the smart contract.
    #
    # source://eth//lib/eth/contract.rb#88
    def from_bin(bin:, abi:, name:); end

    # Creates a contract wrapper from a Solidity file.
    #
    # @param file [String] solidity file path.
    # @param contract_index [Number] specify contract.
    # @raise [ArgumentError] if the file path is empty or no contracts were compiled.
    # @return [Eth::Contract::Object] Returns the class of the smart contract.
    #
    # source://eth//lib/eth/contract.rb#56
    def from_file(file:, contract_index: T.unsafe(nil)); end
  end
end

# source://eth//lib/eth/contract/event.rb#21
class Eth::Contract::Event
  # source://eth//lib/eth/contract/event.rb#27
  def initialize(data); end

  # source://eth//lib/eth/contract/event.rb#22
  def address; end

  # source://eth//lib/eth/contract/event.rb#22
  def address=(_arg0); end

  # source://eth//lib/eth/contract/event.rb#22
  def event_string; end

  # source://eth//lib/eth/contract/event.rb#22
  def event_string=(_arg0); end

  # source://eth//lib/eth/contract/event.rb#22
  def input_types; end

  # source://eth//lib/eth/contract/event.rb#22
  def input_types=(_arg0); end

  # source://eth//lib/eth/contract/event.rb#22
  def inputs; end

  # source://eth//lib/eth/contract/event.rb#22
  def inputs=(_arg0); end

  # source://eth//lib/eth/contract/event.rb#22
  def name; end

  # source://eth//lib/eth/contract/event.rb#22
  def name=(_arg0); end

  # source://eth//lib/eth/contract/event.rb#40
  def set_address(address); end

  # source://eth//lib/eth/contract/event.rb#22
  def signature; end

  # source://eth//lib/eth/contract/event.rb#22
  def signature=(_arg0); end

  private

  # source://eth//lib/eth/contract/event.rb#46
  def type_name(x); end
end

# source://eth//lib/eth/contract/function.rb#21
class Eth::Contract::Function
  # source://eth//lib/eth/contract/function.rb#27
  def initialize(data); end

  # source://eth//lib/eth/contract/function.rb#22
  def constant; end

  # source://eth//lib/eth/contract/function.rb#22
  def constant=(_arg0); end

  # source://eth//lib/eth/contract/function.rb#22
  def function_string; end

  # source://eth//lib/eth/contract/function.rb#22
  def function_string=(_arg0); end

  # source://eth//lib/eth/contract/function.rb#22
  def inputs; end

  # source://eth//lib/eth/contract/function.rb#22
  def inputs=(_arg0); end

  # source://eth//lib/eth/contract/function.rb#22
  def name; end

  # source://eth//lib/eth/contract/function.rb#22
  def name=(_arg0); end

  # source://eth//lib/eth/contract/function.rb#22
  def outputs; end

  # source://eth//lib/eth/contract/function.rb#22
  def outputs=(_arg0); end

  # source://eth//lib/eth/contract/function.rb#22
  def signature; end

  # source://eth//lib/eth/contract/function.rb#22
  def signature=(_arg0); end

  class << self
    # source://eth//lib/eth/contract/function.rb#45
    def calc_signature(name, inputs); end

    # source://eth//lib/eth/contract/function.rb#53
    def encoded_function_signature(signature); end
  end
end

# source://eth//lib/eth/contract/function_input.rb#21
class Eth::Contract::FunctionInput
  # source://eth//lib/eth/contract/function_input.rb#27
  def initialize(data); end

  # source://eth//lib/eth/contract/function_input.rb#22
  def name; end

  # source://eth//lib/eth/contract/function_input.rb#22
  def name=(_arg0); end

  # source://eth//lib/eth/contract/function_input.rb#39
  def parsed_type; end

  # source://eth//lib/eth/contract/function_input.rb#22
  def raw_type; end

  # source://eth//lib/eth/contract/function_input.rb#22
  def raw_type=(_arg0); end

  # source://eth//lib/eth/contract/function_input.rb#34
  def type; end

  # source://eth//lib/eth/contract/function_input.rb#22
  def type=(_arg0); end
end

# source://eth//lib/eth/contract/function_output.rb#21
class Eth::Contract::FunctionOutput
  # source://eth//lib/eth/contract/function_output.rb#27
  def initialize(data); end

  # source://eth//lib/eth/contract/function_output.rb#22
  def name; end

  # source://eth//lib/eth/contract/function_output.rb#22
  def name=(_arg0); end

  # source://eth//lib/eth/contract/function_output.rb#33
  def type; end

  # source://eth//lib/eth/contract/function_output.rb#22
  def type=(_arg0); end
end

# source://eth//lib/eth/contract/initializer.rb#21
class Eth::Contract::Initializer
  # source://eth//lib/eth/contract/initializer.rb#27
  def initialize(file); end

  # source://eth//lib/eth/contract/initializer.rb#41
  def build_all; end

  # source://eth//lib/eth/contract/initializer.rb#22
  def contracts; end

  # source://eth//lib/eth/contract/initializer.rb#22
  def contracts=(_arg0); end

  # source://eth//lib/eth/contract/initializer.rb#22
  def file; end

  # source://eth//lib/eth/contract/initializer.rb#22
  def file=(_arg0); end
end

# Defines handy tools for encoding typed structured data as per EIP-712.
# Ref: https://eips.ethereum.org/EIPS/eip-712
#
# source://eth//lib/eth/eip712.rb#20
module Eth::Eip712
  extend ::Eth::Eip712

  # Recursively ABI-encodes all data and types according to EIP-712.
  #
  # @param primary_type [String] the primary type which we want to encode.
  # @param data [Array] the data in the data structure we want to encode.
  # @param types [Array] all existing types in the data structure.
  # @return [String] an ABI-encoded representation of the data and the types.
  #
  # source://eth//lib/eth/eip712.rb#106
  def encode_data(primary_type, data, types); end

  # Encode types as an EIP-712 confrom string, e.g.,
  # `MyType(string attribute)`.
  #
  # @param primary_type [String] the type which we want to encode.
  # @param types [Array] all existing types in the data structure.
  # @raise [TypedDataError] if non-primary type found.
  # @return [String] an EIP-712 encoded type-string.
  #
  # source://eth//lib/eth/eip712.rb#63
  def encode_type(primary_type, types); end

  # Enforces basic properties to be represented in the EIP-712 typed
  # data structure: types, domain, message, etc.
  #
  # @param data [Array] the data in the data structure we want to hash.
  # @raise [TypedDataError] if the data fails validation.
  # @return [Array] the data in the data structure we want to hash.
  #
  # source://eth//lib/eth/eip712.rb#155
  def enforce_typed_data(data); end

  # Hashes a typed data structure with Keccak-256 to prepare a signed
  # typed data operation respecting EIP-712.
  #
  # @param data [Array] all the data in the typed data structure.
  # @return [String] a Keccak-256 hash of the EIP-712-encoded typed data.
  #
  # source://eth//lib/eth/eip712.rb#171
  def hash(data); end

  # Recursively ABI-encodes and hashes all data and types.
  #
  # @param primary_type [String] the primary type which we want to hash.
  # @param data [Array] the data in the data structure we want to hash.
  # @param types [Array] all existing types in the data structure.
  # @return [String] a Keccak-256 hash of the ABI-encoded data and types.
  #
  # source://eth//lib/eth/eip712.rb#144
  def hash_data(primary_type, data, types); end

  # Hashes an EIP-712 confrom type-string.
  #
  # @param primary_type [String] the type which we want to hash.
  # @param types [Array] all existing types in the data structure.
  # @return [String] a Keccak-256 hash of an EIP-712 encoded type-string.
  #
  # source://eth//lib/eth/eip712.rb#95
  def hash_type(primary_type, types); end

  # Scans all dependencies of a given type recursively and returns
  # either all dependencies or none if not found.
  #
  # @param primary_type [String] the primary type which we want to scan.
  # @param types [Array] all existing types in the data structure.
  # @param result [Array] found results from previous recursions.
  # @return [Array] all dependent types for the given primary type.
  #
  # source://eth//lib/eth/eip712.rb#34
  def type_dependencies(primary_type, types, result = T.unsafe(nil)); end
end

# Provides a special typed-data error if data structure fails basic
# verification.
#
# source://eth//lib/eth/eip712.rb#25
class Eth::Eip712::TypedDataError < ::StandardError; end

# Provides ENS specific functionality
# ref: https://ens.domains
#
# source://eth//lib/eth/ens/coin_type.rb#19
module Eth::Ens
  extend ::Eth::Ens
end

# Provides EIP-2304 / SLIP-44 cointypes to resolve ENS addresses.
# ref: https://eips.ethereum.org/EIPS/eip-2304
#
# source://eth//lib/eth/ens/coin_type.rb#22
module Eth::Ens::CoinType
  extend ::Eth::Ens::CoinType
end

# ENS coin type for Binance.
#
# source://eth//lib/eth/ens/coin_type.rb#47
Eth::Ens::CoinType::BINANCE = T.let(T.unsafe(nil), Integer)

# ENS coin type for Bitcoin.
#
# source://eth//lib/eth/ens/coin_type.rb#26
Eth::Ens::CoinType::BITCOIN = T.let(T.unsafe(nil), Integer)

# ENS coin type for Bitcoin Cash.
#
# source://eth//lib/eth/ens/coin_type.rb#44
Eth::Ens::CoinType::BITCOIN_CASH = T.let(T.unsafe(nil), Integer)

# ENS coin type for Dogecoin.
#
# source://eth//lib/eth/ens/coin_type.rb#32
Eth::Ens::CoinType::DOGECOIN = T.let(T.unsafe(nil), Integer)

# ENS coin type for Ethereum.
#
# source://eth//lib/eth/ens/coin_type.rb#35
Eth::Ens::CoinType::ETHEREUM = T.let(T.unsafe(nil), Integer)

# ENS coin type for Ethereum Classic.
#
# source://eth//lib/eth/ens/coin_type.rb#38
Eth::Ens::CoinType::ETHEREUM_CLASSIC = T.let(T.unsafe(nil), Integer)

# ENS coin type for Litecoin.
#
# source://eth//lib/eth/ens/coin_type.rb#29
Eth::Ens::CoinType::LITECOIN = T.let(T.unsafe(nil), Integer)

# ENS coin type for Rootstock.
#
# source://eth//lib/eth/ens/coin_type.rb#41
Eth::Ens::CoinType::ROOTSTOCK = T.let(T.unsafe(nil), Integer)

# The default address for ENS, which applies to most chains
#
# source://eth//lib/eth/ens.rb#26
Eth::Ens::DEFAULT_ADDRESS = T.let(T.unsafe(nil), Eth::Address)

# Utility class for resolving ENS names to Ethereum addresses
#
# source://eth//lib/eth/ens/resolver.rb#25
class Eth::Ens::Resolver
  # Create an instance of the ENS Resolver.
  #
  # @param client [Eth::Client] The client instance used to resolve the ENS.
  # @param address [String] The address of the ENS registry on the given chain.
  # @return [Resolver] a new instance of Resolver
  #
  # source://eth//lib/eth/ens/resolver.rb#37
  def initialize(client, address = T.unsafe(nil)); end

  # The client instance used to resolve the ENS.
  #
  # source://eth//lib/eth/ens/resolver.rb#28
  def client; end

  # The client instance used to resolve the ENS.
  #
  # source://eth//lib/eth/ens/resolver.rb#28
  def client=(_arg0); end

  # Generate node for the given domain name
  # See: https://docs.ens.domains/contract-api-reference/name-processing
  #
  # @param ens_name [String] The ENS name, e.g., `fancy.eth`.
  # @return [String] The node as a hex string.
  #
  # source://eth//lib/eth/ens/resolver.rb#97
  def namehash(ens_name); end

  # Normalize a string as specified by http://unicode.org/reports/tr46/
  #
  # @param input [String] The input string
  # @return [String] The normalized output string
  #
  # source://eth//lib/eth/ens/resolver.rb#111
  def normalize(input); end

  # Resolve an ENS name owner.
  #
  # @param ens_name [String] The ENS name, e.g., `fancy.eth`.
  # @return [String] The owner address of the name as a hex string.
  #
  # source://eth//lib/eth/ens/resolver.rb#50
  def owner(ens_name); end

  # The address of the ENS registry on the given chain.
  #
  # source://eth//lib/eth/ens/resolver.rb#31
  def registry; end

  # The address of the ENS registry on the given chain.
  #
  # source://eth//lib/eth/ens/resolver.rb#31
  def registry=(_arg0); end

  # Resolve an ENS name to an address.
  #
  # @param ens_name [String] The ENS name, e.g., `fancy.eth`.
  # @return [String] The owner address of the name as a hex string.
  #
  # source://eth//lib/eth/ens/resolver.rb#72
  def resolve(ens_name, coin_type = T.unsafe(nil)); end

  # Retrieve the public resolver for the given ENS name.
  #
  # @param ens_name [String] The ENS name, e.g., `fancy.eth`.
  # @return [Eth::Contract] The public resolver contract that can be used
  #   to resolve ENS names.
  #
  # source://eth//lib/eth/ens/resolver.rb#59
  def resolver(ens_name); end

  # Resolve a text record for a given ENS name.
  #
  # @param ens_name [String] The ENS name, e.g., `fancy.eth`.
  # @param key [String] The key for the text record, e.g., `url`.
  # @return [String] The text record.
  #
  # source://eth//lib/eth/ens/resolver.rb#88
  def text(ens_name, key = T.unsafe(nil)); end
end

# The {Eth::Key} class to handle Secp256k1 private/public key-pairs.
#
# source://eth//lib/eth/key.rb#25
class Eth::Key
  # Constructor of the {Eth::Key} class. Creates a new random key-pair
  # if no `priv` key is provided.
  #
  # @param priv [String] binary string of private key data.
  # @return [Key] a new instance of Key
  #
  # source://eth//lib/eth/key.rb#43
  def initialize(priv: T.unsafe(nil)); end

  # Exports the checksummed public address.
  #
  # @return [Eth::Address] compressed address as packed hex prefixed string.
  #
  # source://eth//lib/eth/key.rb#163
  def address; end

  # Prefixes a message with `\x19Ethereum Signed Message:` and signs
  # it in the common way used by many web3 wallets. Complies with
  # EIP-191 prefix `0x19` and version byte `0x45` (`E`). See also
  # {Signature.personal_recover}.
  # Ref: https://eips.ethereum.org/EIPS/eip-191
  #
  # @param message [String] the message string to be prefixed and signed.
  # @param chain_id [Integer] the chain id the signature should be generated on.
  # @return [String] an EIP-191 conform, hexa-decimal signature.
  #
  # source://eth//lib/eth/key.rb#94
  def personal_sign(message, chain_id = T.unsafe(nil)); end

  # Exports the private key bytes in a wrapper function to maintain
  # backward-compatibility with older versions of {Eth::Key}.
  #
  # @return [String] private key as packed byte-string.
  #
  # source://eth//lib/eth/key.rb#125
  def private_bytes; end

  # Converts the private key data into a hexa-decimal string.
  #
  # @return [String] private key as hexa-decimal string.
  #
  # source://eth//lib/eth/key.rb#117
  def private_hex; end

  # The `Secp256k1::PrivateKey` of the {Eth::Key} pair.
  #
  # source://eth//lib/eth/key.rb#34
  def private_key; end

  # Exports the uncompressed public key bytes in a wrapper function to
  # maintain backward-compatibility with older versions of {Eth::Key}.
  #
  # @return [String] uncompressed public key as packed byte-string.
  #
  # source://eth//lib/eth/key.rb#149
  def public_bytes; end

  # Exports the compressed public key bytes.
  #
  # @return [String] compressed public key as packed byte-string.
  #
  # source://eth//lib/eth/key.rb#156
  def public_bytes_compressed; end

  # Converts the public key data into an uncompressed
  # hexa-decimal string.
  #
  # @return [String] public key as uncompressed hexa-decimal string.
  #
  # source://eth//lib/eth/key.rb#133
  def public_hex; end

  # Converts the public key data into an compressed
  # hexa-decimal string.
  #
  # @return [String] public key as compressed hexa-decimal string.
  #
  # source://eth//lib/eth/key.rb#141
  def public_hex_compressed; end

  # The `Secp256k1::PublicKey` of the {Eth::Key} pair.
  #
  # source://eth//lib/eth/key.rb#37
  def public_key; end

  # Signs arbitrary data without validation. Should not be used unless really
  # desired. See also: {Key.personal_sign}, {Key.sign_typed_data}, and
  # {Signature.recover}.
  #
  # @param blob [Object] that arbitrary data to be signed.
  # @param chain_id [Integer] the chain id the signature should be generated on.
  # @return [String] a hexa-decimal signature.
  #
  # source://eth//lib/eth/key.rb#72
  def sign(blob, chain_id = T.unsafe(nil)); end

  # Prefixes, hashes, and signes a typed data structure in the common
  # way used by many web3 wallets. Complies with EIP-191 prefix `0x19`
  # and EIP-712 version byte `0x01`. Supports `V3`, `V4`. See also
  # {Signature.recover_typed_data}.
  # Ref: https://eips.ethereum.org/EIPS/eip-712
  #
  # @param typed_data [Array] all the data in the typed data structure to be signed.
  # @param chain_id [Integer] the chain id the signature should be generated on.
  # @return [String] an EIP-712 conform, hexa-decimal signature.
  #
  # source://eth//lib/eth/key.rb#109
  def sign_typed_data(typed_data, chain_id = T.unsafe(nil)); end
end

# source://eth//lib/eth/key/decrypter.rb#19
class Eth::Key::Decrypter
  # source://eth//lib/eth/key/decrypter.rb#40
  def initialize(data, password); end

  # source://eth//lib/eth/key/decrypter.rb#49
  def perform; end

  private

  # source://eth//lib/eth/key/decrypter.rb#73
  def check_macs; end

  # source://eth//lib/eth/key/decrypter.rb#98
  def cipher; end

  # source://eth//lib/eth/key/decrypter.rb#94
  def cipher_name; end

  # source://eth//lib/eth/key/decrypter.rb#90
  def ciphertext; end

  # source://eth//lib/eth/key/decrypter.rb#86
  def crypto_data; end

  # source://eth//lib/eth/key/decrypter.rb#58
  def data; end

  # source://eth//lib/eth/key/decrypter.rb#82
  def decrypted_data; end

  # source://eth//lib/eth/key/decrypter.rb#62
  def derive_key(password); end

  # source://eth//lib/eth/key/decrypter.rb#138
  def digest; end

  # source://eth//lib/eth/key/decrypter.rb#142
  def digest_name; end

  # source://eth//lib/eth/key/decrypter.rb#114
  def iterations; end

  # source://eth//lib/eth/key/decrypter.rb#106
  def iv; end

  # source://eth//lib/eth/key/decrypter.rb#118
  def kdf; end

  # source://eth//lib/eth/key/decrypter.rb#59
  def key; end

  # source://eth//lib/eth/key/decrypter.rb#122
  def key_length; end

  # source://eth//lib/eth/key/decrypter.rb#126
  def n; end

  # source://eth//lib/eth/key/decrypter.rb#134
  def p; end

  # source://eth//lib/eth/key/decrypter.rb#60
  def password; end

  # source://eth//lib/eth/key/decrypter.rb#130
  def r; end

  # source://eth//lib/eth/key/decrypter.rb#110
  def salt; end

  class << self
    # source://eth//lib/eth/key/decrypter.rb#30
    def perform(data, password); end
  end
end

# source://eth//lib/eth/key/decrypter.rb#22
class Eth::Key::Decrypter::DecrypterError < ::StandardError; end

# source://eth//lib/eth/key/encrypter.rb#19
class Eth::Key::Encrypter
  # source://eth//lib/eth/key/encrypter.rb#54
  def initialize(key, options = T.unsafe(nil)); end

  # source://eth//lib/eth/key/encrypter.rb#80
  def data; end

  # source://eth//lib/eth/key/encrypter.rb#70
  def perform(password); end

  private

  # source://eth//lib/eth/key/encrypter.rb#203
  def block_size; end

  # source://eth//lib/eth/key/encrypter.rb#119
  def cipher; end

  # source://eth//lib/eth/key/encrypter.rb#151
  def cipher_name; end

  # source://eth//lib/eth/key/encrypter.rb#131
  def derive_key(password); end

  # source://eth//lib/eth/key/encrypter.rb#117
  def derived_key; end

  # source://eth//lib/eth/key/encrypter.rb#127
  def digest; end

  # source://eth//lib/eth/key/encrypter.rb#155
  def digest_name; end

  # source://eth//lib/eth/key/encrypter.rb#139
  def encrypt; end

  # source://eth//lib/eth/key/encrypter.rb#117
  def encrypted_key; end

  # source://eth//lib/eth/key/encrypter.rb#175
  def id; end

  # source://eth//lib/eth/key/encrypter.rb#179
  def iterations; end

  # source://eth//lib/eth/key/encrypter.rb#191
  def iv; end

  # source://eth//lib/eth/key/encrypter.rb#171
  def iv_length; end

  # source://eth//lib/eth/key/encrypter.rb#147
  def kdf; end

  # source://eth//lib/eth/key/encrypter.rb#117
  def key; end

  # source://eth//lib/eth/key/encrypter.rb#163
  def key_length; end

  # source://eth//lib/eth/key/encrypter.rb#143
  def mac; end

  # source://eth//lib/eth/key/encrypter.rb#117
  def options; end

  # source://eth//lib/eth/key/encrypter.rb#199
  def parallelization; end

  # source://eth//lib/eth/key/encrypter.rb#159
  def prf; end

  # source://eth//lib/eth/key/encrypter.rb#183
  def salt; end

  # source://eth//lib/eth/key/encrypter.rb#167
  def salt_length; end

  class << self
    # source://eth//lib/eth/key/encrypter.rb#37
    def perform(key, password, options = T.unsafe(nil)); end
  end
end

# source://eth//lib/eth/key/encrypter.rb#22
class Eth::Key::Encrypter::EncrypterError < ::StandardError; end

# Defines the major version of the {Eth} module.
#
# source://eth//lib/eth/version.rb#19
Eth::MAJOR = T.let(T.unsafe(nil), Integer)

# Defines the minor version of the {Eth} module.
#
# source://eth//lib/eth/version.rb#22
Eth::MINOR = T.let(T.unsafe(nil), Integer)

# Defines the patch version of the {Eth} module.
#
# source://eth//lib/eth/version.rb#25
Eth::PATCH = T.let(T.unsafe(nil), Integer)

# Provides an recursive-length prefix (RLP) encoder and decoder.
#
# source://eth//lib/eth/rlp/decoder.rb#21
module Eth::Rlp
  extend ::Eth::Rlp

  # Performes an {Eth::Rlp::Decoder} on any RLP-encoded item.
  #
  # @param rlp [String] a packed, RLP-encoded item.
  # @return [Object] a decoded ruby object.
  #
  # source://eth//lib/eth/rlp.rb#59
  def decode(rlp); end

  # Performes an {Eth::Rlp::Encoder} on any ruby object.
  #
  # @param obj [Object] any ruby object.
  # @return [String] a packed, RLP-encoded item.
  #
  # source://eth//lib/eth/rlp.rb#51
  def encode(obj); end
end

# A wrapper to represent already RLP-encoded data.
#
# source://eth//lib/eth/rlp.rb#45
class Eth::Rlp::Data < ::String; end

# Provides an RLP-decoder.
#
# source://eth//lib/eth/rlp/decoder.rb#24
module Eth::Rlp::Decoder
  extend ::Eth::Rlp::Decoder

  # Decodes an RLP-encoded object.
  #
  # @param rlp [String] an RLP-encoded object.
  # @raise [Eth::Rlp::DecodingError] if the input string does not end after
  #   the root item.
  # @return [Object] the decoded and maybe deserialized object.
  #
  # source://eth//lib/eth/rlp/decoder.rb#33
  def perform(rlp); end

  private

  # Consume an RLP-encoded item from the given start.
  #
  # source://eth//lib/eth/rlp/decoder.rb#48
  def consume_item(rlp, start); end

  # Consume an RLP length prefix at the given position.
  #
  # source://eth//lib/eth/rlp/decoder.rb#54
  def consume_length_prefix(rlp, start); end

  # Consume an RLP payload at the given position of given type and size.
  #
  # source://eth//lib/eth/rlp/decoder.rb#94
  def consume_payload(rlp, start, type, length); end

  # Enforce RLP slices to not start with empty bytes.
  #
  # @raise [DecodingError]
  #
  # source://eth//lib/eth/rlp/decoder.rb#89
  def enforce_no_zero_bytes(rlp, start); end
end

# An error-type to point out RLP-decoding errors.
#
# source://eth//lib/eth/rlp.rb#36
class Eth::Rlp::DecodingError < ::Eth::Rlp::RlpException; end

# An error-type to point out RLP-type serialization errors.
#
# source://eth//lib/eth/rlp.rb#42
class Eth::Rlp::DeserializationError < ::Eth::Rlp::RlpException; end

# Provides an RLP-encoder.
#
# source://eth//lib/eth/rlp/encoder.rb#24
module Eth::Rlp::Encoder
  extend ::Eth::Rlp::Encoder

  # Encodes a Ruby object in RLP format.
  #
  # @param obj [Object] a Ruby object.
  # @raise [Eth::Rlp::EncodingError] in the rather unlikely case that the item
  #   is too big to encode (will not happen).
  # @raise [Eth::Rlp::SerializationError] if the serialization fails.
  # @return [String] the RLP encoded item.
  #
  # source://eth//lib/eth/rlp/encoder.rb#34
  def perform(obj); end

  private

  # Encodes a single list.
  #
  # source://eth//lib/eth/rlp/encoder.rb#58
  def encode_list(list); end

  # Encodes a single primitive.
  #
  # source://eth//lib/eth/rlp/encoder.rb#50
  def encode_primitive(item); end

  # Encodes the raw item.
  #
  # source://eth//lib/eth/rlp/encoder.rb#42
  def encode_raw(item); end

  # Determines a length prefix.
  #
  # source://eth//lib/eth/rlp/encoder.rb#65
  def length_prefix(length, offset); end
end

# An error-type to point out RLP-encoding errors.
#
# source://eth//lib/eth/rlp.rb#33
class Eth::Rlp::EncodingError < ::Eth::Rlp::RlpException; end

# The Rlp module exposes a variety of exceptions grouped as {RlpException}.
#
# source://eth//lib/eth/rlp.rb#30
class Eth::Rlp::RlpException < ::StandardError; end

# Provides serializable and deserializable types (SeDes).
#
# source://eth//lib/eth/rlp/sedes/big_endian_int.rb#24
module Eth::Rlp::Sedes
  class << self
    # A utility to use a big-endian, unsigned integer sedes type with
    # unspecified length.
    #
    # @return [Eth::Rlp::Sedes::BigEndianInt] a big-endian, unsigned integer sedes.
    #
    # source://eth//lib/eth/rlp/sedes.rb#61
    def big_endian_int; end

    # A utility to use a binary sedes type.
    #
    # @return [Eth::Rlp::Sedes::Binary] a binary sedes.
    #
    # source://eth//lib/eth/rlp/sedes.rb#68
    def binary; end

    # Tries to find a sedes objects suitable for a given Ruby object.
    #
    # The sedes objects considered are `obj`'s class, {big_endian_int} and
    # {binary}. If `obj` is a list, an {Eth::Rlp::Sedes::List} will be
    # constructed recursively.
    #
    # @param obj [Object] the Ruby object for which to find a sedes object.
    # @raise [TypeError] if no appropriate sedes could be found.
    #
    # source://eth//lib/eth/rlp/sedes.rb#41
    def infer(obj); end

    # Determines if an object is a sedes object.
    #
    # @param obj [Object] the object to check.
    # @return [Boolean] true if it's serializable and deserializable.
    #
    # source://eth//lib/eth/rlp/sedes.rb#53
    def sedes?(obj); end
  end
end

# A serializable, big-endian, unsigned integer type.
#
# source://eth//lib/eth/rlp/sedes/big_endian_int.rb#27
class Eth::Rlp::Sedes::BigEndianInt
  # Create a serializable, big-endian, unsigned integer.
  #
  # @param size [Integer] the size of the big endian.
  # @return [BigEndianInt] a new instance of BigEndianInt
  #
  # source://eth//lib/eth/rlp/sedes/big_endian_int.rb#32
  def initialize(size = T.unsafe(nil)); end

  # Deserializes an unsigned integer.
  #
  # @param serial [String] the serialized integer.
  # @raise [DeserializationError] if provided serial is of wrong size.
  # @raise [DeserializationError] if provided serial is not of minimal length.
  # @return [Integer] a number.
  #
  # source://eth//lib/eth/rlp/sedes/big_endian_int.rb#57
  def deserialize(serial); end

  # Serialize a big-endian integer.
  #
  # @param obj [Integer] the integer to be serialized.
  # @raise [SerializationError] if provided object is not an integer.
  # @raise [SerializationError] if provided integer is negative.
  # @raise [SerializationError] if provided integer is too big for @size.
  # @return [String] a serialized big-endian integer.
  #
  # source://eth//lib/eth/rlp/sedes/big_endian_int.rb#43
  def serialize(obj); end
end

# A sedes type for binary values.
#
# source://eth//lib/eth/rlp/sedes/binary.rb#27
class Eth::Rlp::Sedes::Binary
  # Create a serializable binary of variable size.
  #
  # @param min_length [Integer] the minimum size of the binary.
  # @param max_length [Integer] the maximum size of the binary.
  # @param allow_empty [Boolean] indicator wether empty binaries should be allowed.
  # @return [Binary] a new instance of Binary
  #
  # source://eth//lib/eth/rlp/sedes/binary.rb#55
  def initialize(min_length: T.unsafe(nil), max_length: T.unsafe(nil), allow_empty: T.unsafe(nil)); end

  # Deserializes a binary.
  #
  # @param serial [Object] the serialized binary.
  # @raise [DeserializationError] if provided serial is of wrong type.
  # @raise [DeserializationError] if provided serial is of wrong length.
  # @return [String] a deserialized binary.
  #
  # source://eth//lib/eth/rlp/sedes/binary.rb#80
  def deserialize(serial); end

  # Serializes a binary.
  #
  # @param obj [String] the binary to serialize.
  # @raise [SerializationError] if provided object is of invalid type.
  # @raise [SerializationError] if provided binary is of invalid length.
  # @return [Object] a serialized binary.
  #
  # source://eth//lib/eth/rlp/sedes/binary.rb#67
  def serialize(obj); end

  # Checks wether the given length fits the defined size boundaries of the
  # binary type.
  #
  # @param length [Integer] the supposed length of the binary item.
  # @return [Boolean] true if valid.
  #
  # source://eth//lib/eth/rlp/sedes/binary.rb#91
  def valid_length?(length); end

  class << self
    # Create a serializable binary of fixed size.
    #
    # @param l [Integer] the fixed size of the binary.
    # @param allow_empty [Boolean] indicator wether empty binaries should be allowed.
    # @return [Eth::Rlp::Sedes::Binary] a serializable binary of fixed size.
    #
    # source://eth//lib/eth/rlp/sedes/binary.rb#37
    def fixed_length(l, allow_empty: T.unsafe(nil)); end

    # Checks wether the given object is of a valid binary type.
    #
    # @param obj [Object] the supposed binary item to check.
    # @return [Boolean] true if valid.
    #
    # source://eth//lib/eth/rlp/sedes/binary.rb#45
    def valid_type?(obj); end
  end
end

# A sedes type for lists of fixed length.
#
# source://eth//lib/eth/rlp/sedes/list.rb#27
class Eth::Rlp::Sedes::List < ::Array
  # Create a serializable list of fixed size.
  #
  # @param elements [Array] an array indicating the structure of the list.
  # @param strict [Boolean] an option to enforce the given structure.
  # @return [List] a new instance of List
  #
  # source://eth//lib/eth/rlp/sedes/list.rb#33
  def initialize(elements: T.unsafe(nil), strict: T.unsafe(nil)); end

  # Deserializes a list.
  #
  # @param serial [Array] the serialized list.
  # @raise [DeserializationError] if provided serial is not a sequence.
  # @raise [DeserializationError] if provided serial is of wrong length.
  # @return [Array] a deserialized list.
  #
  # source://eth//lib/eth/rlp/sedes/list.rb#69
  def deserialize(serial); end

  # Serialize an array.
  #
  # @param obj [Array] the array to be serialized.
  # @raise [SerializationError] if provided array is not a sequence.
  # @raise [SerializationError] if provided array is of wrong length.
  # @return [Array] a serialized list.
  #
  # source://eth//lib/eth/rlp/sedes/list.rb#53
  def serialize(obj); end
end

# An error-type to point out RLP-type serialization errors.
#
# source://eth//lib/eth/rlp.rb#39
class Eth::Rlp::SerializationError < ::Eth::Rlp::RlpException; end

# Defines handy tools for verifying and recovering signatures.
#
# source://eth//lib/eth/signature.rb#21
module Eth::Signature
  extend ::Eth::Signature

  # Dissects a signature blob of 65+ bytes into its `r`, `s`, and `v`
  # values.
  #
  # @param signature [String] a concatenated Secp256k1 signature string.
  # @raise [SignatureError] if signature is of unknown size.
  # @return [String, String, String] the `r`, `s`, and `v` values.
  #
  # source://eth//lib/eth/signature.rb#50
  def dissect(signature); end

  # Recovers a public key from a prefixed, personal message and
  # a signature on a given chain. (EIP-191)
  # Ref: https://eips.ethereum.org/EIPS/eip-191
  #
  # @param message [String] the message string.
  # @param signature [String] the hex string containing the signature.
  # @param chain_id [Integer] the chain ID the signature should be recovered from.
  # @return [String] a hexa-decimal, uncompressed public key.
  #
  # source://eth//lib/eth/signature.rb#92
  def personal_recover(message, signature, chain_id = T.unsafe(nil)); end

  # Prefix message as per EIP-191 with `0x19` to ensure the data is not
  # valid RLP and thus not mistaken for a transaction.
  # EIP-191 Version byte: `0x45` (`E`)
  # Ref: https://eips.ethereum.org/EIPS/eip-191
  #
  # @param message [String] the message string to be prefixed.
  # @return [String] an EIP-191 prefixed string.
  #
  # source://eth//lib/eth/signature.rb#40
  def prefix_message(message); end

  # Recovers a signature from arbitrary data without validation on a given chain.
  #
  # @param blob [String] that arbitrary data to be recovered.
  # @param signature [String] the hex string containing the signature.
  # @param chain_id [Integer] the chain ID the signature should be recovered from.
  # @raise [SignatureError] if signature is of invalid size or invalid v.
  # @return [String] a hexa-decimal, uncompressed public key.
  #
  # source://eth//lib/eth/signature.rb#69
  def recover(blob, signature, chain_id = T.unsafe(nil)); end

  # Recovers a public key from a typed data structure and a signature
  # on a given chain. (EIP-712)
  # Ref: https://eips.ethereum.org/EIPS/eip-712
  #
  # @param typed_data [Array] all the data in the typed data structure to be recovered.
  # @param signature [String] the hex string containing the signature.
  # @param chain_id [Integer] the chain ID the signature should be recovered from.
  # @return [String] a hexa-decimal, uncompressed public key.
  #
  # source://eth//lib/eth/signature.rb#106
  def recover_typed_data(typed_data, signature, chain_id = T.unsafe(nil)); end

  # Verifies a signature for a given public key or address.
  #
  # @param blob [String] that arbitrary data to be verified.
  # @param signature [String] the hex string containing the signature.
  # @param public_key [String] either a public key or an Ethereum address.
  # @param chain_id [Integer] the chain ID used to sign.
  # @raise [SignatureError] if it cannot determine the type of data or public key.
  # @return [Boolean] true if signature matches provided public key.
  #
  # source://eth//lib/eth/signature.rb#119
  def verify(blob, signature, public_key, chain_id = T.unsafe(nil)); end
end

# EIP-191 prefix byte 0x19
#
# source://eth//lib/eth/signature.rb#28
Eth::Signature::EIP191_PREFIX_BYTE = T.let(T.unsafe(nil), String)

# EIP-712 version byte 0x01
#
# source://eth//lib/eth/signature.rb#31
Eth::Signature::EIP712_VERSION_BYTE = T.let(T.unsafe(nil), String)

# Provides a special signature error if signature is invalid.
#
# source://eth//lib/eth/signature.rb#25
class Eth::Signature::SignatureError < ::StandardError; end

# Class to create {Solidity} compiler bingings for Ruby.
#
# source://eth//lib/eth/solidity.rb#21
class Eth::Solidity
  # Instantiates a Solidity `solc` system compiler binding that can be
  # used to compile Solidity contracts.
  #
  # @param path [String] optional override of the solidity compiler path.
  # @raise [SystemCallError]
  # @return [Solidity] a new instance of Solidity
  #
  # source://eth//lib/eth/solidity.rb#33
  def initialize(path = T.unsafe(nil)); end

  # Use the bound Solidity executable to compile the given contract.
  #
  # @param contract [String] path of the contract to compile.
  # @raise [Errno::ENOENT]
  # @return [Array] JSON containing the compiled contract and ABI for all contracts.
  #
  # source://eth//lib/eth/solidity.rb#45
  def compile(contract); end

  # Solidity compiler binary path.
  #
  # source://eth//lib/eth/solidity.rb#27
  def compiler; end

  private

  # Tries to find a system executable path for the given compiler binary name.
  #
  # source://eth//lib/eth/solidity.rb#68
  def get_compiler_path(name = T.unsafe(nil)); end
end

# Provides a Compiler Error in case the contract does not compile.
#
# source://eth//lib/eth/solidity.rb#24
class Eth::Solidity::CompilerError < ::StandardError; end

# Provides the `Tx` module supporting various transaction types.
#
# source://eth//lib/eth/tx/eip1559.rb#19
module Eth::Tx
  extend ::Eth::Tx

  # Decodes a transaction hex of any known type (2, 1, or legacy).
  #
  # @param hex [String] the raw transaction hex-string.
  # @raise [TransactionTypeError] if the transaction type is unknown.
  # @return [Eth::Tx] transaction payload.
  #
  # source://eth//lib/eth/tx.rb#115
  def decode(hex); end

  # Estimates intrinsic gas for provided call data (EIP-2028) and
  # access lists (EIP-2930). Respects initcode word cost (EIP-3860).
  #
  # @param data [String] the call data.
  # @param list [Array] the access list.
  # @return [Integer] the estimated intrinsic gas cost.
  #
  # source://eth//lib/eth/tx.rb#167
  def estimate_intrinsic_gas(data = T.unsafe(nil), list = T.unsafe(nil)); end

  # Creates a new transaction of any type for given parameters and chain ID.
  # Required parameters are (optional in brackets):
  # - EIP-1559: chain_id, nonce, priority_fee, max_gas_fee, gas_limit(, from, to,
  #   value, data, access_list)
  # - EIP-2930: chain_id, nonce, gas_price, gas_limit, access_list(, from, to,
  #   value, data)
  # - Legacy: nonce, gas_price, gas_limit(, from, to, value, data)
  #
  # @param params [Hash] all necessary transaction fields.
  # @param chain_id [Integer] the EIP-155 Chain ID (legacy transactions only).
  #
  # source://eth//lib/eth/tx.rb#91
  def new(params, chain_id = T.unsafe(nil)); end

  # Populates the transaction destination address with a serializable
  # empty value in case it is undefined; also ensures the address is
  # checksummed but not prefixed for consistency.
  #
  # @param addr [String] the transaction destination address.
  # @return [String] the sanitized transaction destination address.
  #
  # source://eth//lib/eth/tx.rb#270
  def sanitize_address(addr); end

  # Populates the transaction value field with a serializable empty value
  # in case it is undefined.
  #
  # @param val [Integer] the transaction value.
  # @return [Integer] the sanitized transaction value.
  #
  # source://eth//lib/eth/tx.rb#284
  def sanitize_amount(val); end

  # Populates the transaction chain id field with a serializable default
  # value (1) in case it is undefined.
  #
  # @param id [Integer] the transaction chain id.
  # @return [Integer] the sanitized transaction chain id.
  #
  # source://eth//lib/eth/tx.rb#259
  def sanitize_chain(id); end

  # Populates the transaction payload field with a serializable empty value
  # in case it is undefined; also ensures the data is binary not hex.
  #
  # @param data [String] the transaction payload data.
  # @return [String] the sanitized transaction payload data.
  #
  # source://eth//lib/eth/tx.rb#294
  def sanitize_data(data); end

  # Populates the transaction access list field with a serializable empty
  # array in case it is undefined; also ensures the nested data is binary
  # not hex.
  #
  # @param list [Array] the transaction access list.
  # @return [Array] the sanitized transaction access list.
  #
  # source://eth//lib/eth/tx.rb#308
  def sanitize_list(list); end

  # Allows to check wether a transaction is signed already.
  #
  # @return [Bool] true if transaction is already signed.
  #
  # source://eth//lib/eth/tx.rb#327
  def signed?(tx); end

  # Creates an unsigned copy of any transaction object.
  #
  # @param tx [Eth::Tx] any transaction payload.
  # @raise [TransactionTypeError] if the transaction type is unknown.
  # @return [Eth::Tx] an unsigned transaction payload of the same type.
  #
  # source://eth//lib/eth/tx.rb#143
  def unsigned_copy(tx); end

  # Validates the common type-2 transaction fields such as priority
  # fee and max gas fee.
  #
  # @param fields [Hash] the transaction fields.
  # @raise [ParameterError] if priority fee is invalid.
  # @raise [ParameterError] if max gas fee is invalid.
  # @return [Hash] the validated transaction fields.
  #
  # source://eth//lib/eth/tx.rb#232
  def validate_eip1559_params(fields); end

  # Validates the common legacy transaction fields such as gas price.
  #
  # @param fields [Hash] the transaction fields.
  # @raise [ParameterError] if gas price is invalid.
  # @return [Hash] the validated transaction fields.
  #
  # source://eth//lib/eth/tx.rb#247
  def validate_legacy_params(fields); end

  # Validates the common transaction fields such as nonce, gas limit,
  # amount, and access list.
  #
  # @param fields [Hash] the transaction fields.
  # @raise [ParameterError] if nonce is an invalid integer.
  # @raise [ParameterError] if gas limit is invalid.
  # @raise [ParameterError] if amount is invalid.
  # @raise [ParameterError] if access list is invalid.
  # @return [Hash] the validated transaction fields.
  #
  # source://eth//lib/eth/tx.rb#209
  def validate_params(fields); end
end

# The maximum transaction gas limit is bound by the block gas limit.
#
# source://eth//lib/eth/tx.rb#64
Eth::Tx::BLOCK_GAS_LIMIT = T.let(T.unsafe(nil), Integer)

# The access list gas cost of an address as per EIP-2930.
#
# source://eth//lib/eth/tx.rb#61
Eth::Tx::COST_ADDRESS = T.let(T.unsafe(nil), Integer)

# The initcode gas cost for each word (32 bytes).
#
# source://eth//lib/eth/tx.rb#55
Eth::Tx::COST_INITCODE_WORD = T.let(T.unsafe(nil), Integer)

# The calldata gas cost of a non-zero byte as per EIP-2028.
#
# source://eth//lib/eth/tx.rb#49
Eth::Tx::COST_NON_ZERO_BYTE = T.let(T.unsafe(nil), Integer)

# The access list gas cost of a storage key as per EIP-2930.
#
# source://eth//lib/eth/tx.rb#58
Eth::Tx::COST_STORAGE_KEY = T.let(T.unsafe(nil), Integer)

# The calldata gas cost of a zero byte.
#
# source://eth//lib/eth/tx.rb#52
Eth::Tx::COST_ZERO_BYTE = T.let(T.unsafe(nil), Integer)

# Smart contract transaction gas cost
#
# source://eth//lib/eth/tx.rb#79
Eth::Tx::CREATE_GAS = T.let(T.unsafe(nil), Integer)

# The minimum transaction gas limit required for a value transfer.
#
# source://eth//lib/eth/tx.rb#40
Eth::Tx::DEFAULT_GAS_LIMIT = T.let(T.unsafe(nil), Integer)

# The "default" transaction gas price of 42.69 GWei. Do not use.
#
# source://eth//lib/eth/tx.rb#46
Eth::Tx::DEFAULT_GAS_PRICE = T.let(T.unsafe(nil), BigDecimal)

# The "default" transaction priority fee of 1.01 GWei. Do not use.
#
# source://eth//lib/eth/tx.rb#43
Eth::Tx::DEFAULT_PRIORITY_FEE = T.let(T.unsafe(nil), BigDecimal)

# Provides an decoder error if transaction cannot be decoded.
#
# source://eth//lib/eth/tx.rb#34
class Eth::Tx::DecoderError < ::StandardError; end

# Provides support for EIP-1559 transactions utilizing EIP-2718
# types and envelopes.
# Ref: https://eips.ethereum.org/EIPS/eip-1559
#
# source://eth//lib/eth/tx/eip1559.rb#24
class Eth::Tx::Eip1559
  extend ::Konstructor::SimpleMethodHook

  # Create a type-2 (EIP-1559) transaction payload object that
  # can be prepared for envelope, signature and broadcast.
  # Ref: https://eips.ethereum.org/EIPS/eip-1559
  #
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @param params [Hash] all necessary transaction fields.
  # @raise [ParameterError] if gas limit is too low.
  # @return [Eip1559] a new instance of Eip1559
  #
  # source://eth//lib/eth/tx/eip1559.rb#86
  def initialize(params); end

  # An optional EIP-2930 access list.
  # Ref: https://eips.ethereum.org/EIPS/eip-2930
  #
  # source://eth//lib/eth/tx/eip1559.rb#53
  def access_list; end

  # The transaction amount in Wei.
  #
  # source://eth//lib/eth/tx/eip1559.rb#46
  def amount; end

  # The EIP-155 Chain ID.
  # Ref: https://eips.ethereum.org/EIPS/eip-155
  #
  # source://eth//lib/eth/tx/eip1559.rb#28
  def chain_id; end

  # The recipient address.
  #
  # source://eth//lib/eth/tx/eip1559.rb#43
  def destination; end

  # Encodes a raw transaction object, wraps it in an EIP-2718 envelope
  # with an EIP-1559 type prefix.
  #
  # @raise [Signature::SignatureError] if the transaction is not yet signed.
  # @return [String] a raw, RLP-encoded EIP-1559 type transaction object.
  #
  # source://eth//lib/eth/tx/eip1559.rb#265
  def encoded; end

  # The gas limit for the transaction.
  #
  # source://eth//lib/eth/tx/eip1559.rb#40
  def gas_limit; end

  # Gets the transaction hash.
  #
  # @return [String] the transaction hash.
  #
  # source://eth//lib/eth/tx/eip1559.rb#299
  def hash; end

  # Gets the encoded, enveloped, raw transaction hex.
  #
  # @return [String] the raw transaction hex.
  #
  # source://eth//lib/eth/tx/eip1559.rb#292
  def hex; end

  # The transaction max fee per gas in Wei.
  #
  # source://eth//lib/eth/tx/eip1559.rb#37
  def max_fee_per_gas; end

  # The transaction max priority fee per gas in Wei.
  #
  # source://eth//lib/eth/tx/eip1559.rb#34
  def max_priority_fee_per_gas; end

  # The transaction data payload.
  #
  # source://eth//lib/eth/tx/eip1559.rb#49
  def payload; end

  # The sender address.
  #
  # source://eth//lib/eth/tx/eip1559.rb#65
  def sender; end

  # Sign the transaction with a given key.
  #
  # @param key [Eth::Key] the key-pair to use for signing.
  # @raise [Signature::SignatureError] if transaction is already signed.
  # @raise [Signature::SignatureError] if sender address does not match signing key.
  # @return [String] a transaction hash.
  #
  # source://eth//lib/eth/tx/eip1559.rb#238
  def sign(key); end

  # The signature `r` value.
  #
  # source://eth//lib/eth/tx/eip1559.rb#59
  def signature_r; end

  # The signature `s` value.
  #
  # source://eth//lib/eth/tx/eip1559.rb#62
  def signature_s; end

  # The signature's y-parity byte (not v).
  #
  # source://eth//lib/eth/tx/eip1559.rb#56
  def signature_y_parity; end

  # The transaction nonce provided by the signer.
  #
  # source://eth//lib/eth/tx/eip1559.rb#31
  def signer_nonce; end

  # The transaction type.
  #
  # source://eth//lib/eth/tx/eip1559.rb#68
  def type; end

  # Encodes the unsigned transaction payload in an EIP-1559 envelope,
  # required for signing.
  #
  # @return [String] an RLP-encoded, unsigned, enveloped EIP-1559 transaction.
  #
  # source://eth//lib/eth/tx/eip1559.rb#307
  def unsigned_encoded; end

  # Gets the sign-hash required to sign a raw transaction.
  #
  # @return [String] a Keccak-256 hash of an unsigned transaction.
  #
  # source://eth//lib/eth/tx/eip1559.rb#328
  def unsigned_hash; end

  private

  # Force-sets an existing signature of a decoded transaction.
  #
  # source://eth//lib/eth/tx/eip1559.rb#335
  def _set_signature(recovery_id, r, s); end

  # Decodes a raw transaction hex into an {Eth::Tx::Eip1559}
  # transaction object.
  #
  # @param hex [String] the raw transaction hex-string.
  # @raise [TransactionTypeError] if transaction type is invalid.
  # @raise [ParameterError] if transaction is missing fields.
  # @raise [DecoderError] if transaction decoding fails.
  # @return [Eth::Tx::Eip1559] transaction payload.
  #
  # source://eth//lib/eth/tx/eip1559.rb#139
  def decode(hex); end

  # Creates an unsigned copy of a transaction payload.
  #
  # @param tx [Eth::Tx::Eip1559] an EIP-1559 transaction payload.
  # @raise [TransactionTypeError] if transaction type does not match.
  # @return [Eth::Tx::Eip1559] an unsigned EIP-1559 transaction payload.
  #
  # source://eth//lib/eth/tx/eip1559.rb#206
  def unsigned_copy(tx); end

  class << self
    # source://konstructor/1.0.2/lib/konstructor/factory.rb#118
    def decode(*args, &block); end

    # source://konstructor/1.0.2/lib/konstructor/factory.rb#118
    def unsigned_copy(*args, &block); end
  end
end

# Provides legacy support for transactions on blockchains that do not
# implement EIP-1559 but still want to utilize EIP-2718 envelopes.
# Ref: https://eips.ethereum.org/EIPS/eip-2930
#
# source://eth//lib/eth/tx/eip2930.rb#24
class Eth::Tx::Eip2930
  extend ::Konstructor::SimpleMethodHook

  # Create a legacy type-1 (EIP-2930) transaction payload object that
  # can be prepared for envelope, signature and broadcast. Should not
  # be used unless there is no EIP-1559 support.
  # Ref: https://eips.ethereum.org/EIPS/eip-2930
  #
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @param params [Hash] all necessary transaction fields.
  # @raise [ParameterError] if gas limit is too low.
  # @return [Eip2930] a new instance of Eip2930
  #
  # source://eth//lib/eth/tx/eip2930.rb#84
  def initialize(params); end

  # An optional EIP-2930 access list.
  # Ref: https://eips.ethereum.org/EIPS/eip-2930
  #
  # source://eth//lib/eth/tx/eip2930.rb#50
  def access_list; end

  # The transaction amount in Wei.
  #
  # source://eth//lib/eth/tx/eip2930.rb#43
  def amount; end

  # The EIP-155 Chain ID.
  # Ref: https://eips.ethereum.org/EIPS/eip-155
  #
  # source://eth//lib/eth/tx/eip2930.rb#28
  def chain_id; end

  # The recipient address.
  #
  # source://eth//lib/eth/tx/eip2930.rb#40
  def destination; end

  # Encodes a raw transaction object, wraps it in an EIP-2718 envelope
  # with an EIP-2930 type prefix.
  #
  # @raise [Signature::SignatureError] if the transaction is not yet signed.
  # @return [String] a raw, RLP-encoded EIP-2930 type transaction object.
  #
  # source://eth//lib/eth/tx/eip2930.rb#259
  def encoded; end

  # The gas limit for the transaction.
  #
  # source://eth//lib/eth/tx/eip2930.rb#37
  def gas_limit; end

  # The gas price for the transaction in Wei.
  #
  # source://eth//lib/eth/tx/eip2930.rb#34
  def gas_price; end

  # Gets the transaction hash.
  #
  # @return [String] the transaction hash.
  #
  # source://eth//lib/eth/tx/eip2930.rb#292
  def hash; end

  # Gets the encoded, enveloped, raw transaction hex.
  #
  # @return [String] the raw transaction hex.
  #
  # source://eth//lib/eth/tx/eip2930.rb#285
  def hex; end

  # The transaction data payload.
  #
  # source://eth//lib/eth/tx/eip2930.rb#46
  def payload; end

  # The sender address.
  #
  # source://eth//lib/eth/tx/eip2930.rb#62
  def sender; end

  # Sign the transaction with a given key.
  #
  # @param key [Eth::Key] the key-pair to use for signing.
  # @raise [Signature::SignatureError] if transaction is already signed.
  # @raise [Signature::SignatureError] if sender address does not match signing key.
  # @return [String] a transaction hash.
  #
  # source://eth//lib/eth/tx/eip2930.rb#232
  def sign(key); end

  # The signature `r` value.
  #
  # source://eth//lib/eth/tx/eip2930.rb#56
  def signature_r; end

  # The signature `s` value.
  #
  # source://eth//lib/eth/tx/eip2930.rb#59
  def signature_s; end

  # The signature's `y`-parity byte (not `v`).
  #
  # source://eth//lib/eth/tx/eip2930.rb#53
  def signature_y_parity; end

  # The transaction nonce provided by the signer.
  #
  # source://eth//lib/eth/tx/eip2930.rb#31
  def signer_nonce; end

  # The transaction type.
  #
  # source://eth//lib/eth/tx/eip2930.rb#65
  def type; end

  # Encodes the unsigned transaction payload in an EIP-2930 envelope,
  # required for signing.
  #
  # @return [String] an RLP-encoded, unsigned, enveloped EIP-2930 transaction.
  #
  # source://eth//lib/eth/tx/eip2930.rb#300
  def unsigned_encoded; end

  # Gets the sign-hash required to sign a raw transaction.
  #
  # @return [String] a Keccak-256 hash of an unsigned transaction.
  #
  # source://eth//lib/eth/tx/eip2930.rb#320
  def unsigned_hash; end

  private

  # Force-sets an existing signature of a decoded transaction.
  #
  # source://eth//lib/eth/tx/eip2930.rb#327
  def _set_signature(recovery_id, r, s); end

  # Decodes a raw transaction hex into an {Eth::Tx::Eip2930}
  # transaction object.
  #
  # @param hex [String] the raw transaction hex-string.
  # @raise [TransactionTypeError] if transaction type is invalid.
  # @raise [ParameterError] if transaction is missing fields.
  # @raise [DecoderError] if transaction decoding fails.
  # @return [Eth::Tx::Eip2930] transaction payload.
  #
  # source://eth//lib/eth/tx/eip2930.rb#136
  def decode(hex); end

  # Creates an unsigned copy of a transaction payload.
  #
  # @param tx [Eth::Tx::Eip2930] an EIP-2930 transaction payload.
  # @raise [TransactionTypeError] if transaction type does not match.
  # @return [Eth::Tx::Eip2930] an unsigned EIP-2930 transaction payload.
  #
  # source://eth//lib/eth/tx/eip2930.rb#201
  def unsigned_copy(tx); end

  class << self
    # source://konstructor/1.0.2/lib/konstructor/factory.rb#118
    def decode(*args, &block); end

    # source://konstructor/1.0.2/lib/konstructor/factory.rb#118
    def unsigned_copy(*args, &block); end
  end
end

# Provides legacy support for transactions on blockchains that do not
# implement EIP-1559, EIP-2718, or EIP-2930.
#
# source://eth//lib/eth/tx/legacy.rb#23
class Eth::Tx::Legacy
  extend ::Konstructor::SimpleMethodHook

  # Create a legacy transaction object that can be prepared for
  # signature and broadcast. Should not be used unless there is
  # no EIP-1559 support.
  #
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @option params
  # @param params [Hash] all necessary transaction fields.
  # @param chain_id [Integer] the EIP-155 Chain ID.
  # @raise [ParameterError] if gas limit is too low.
  # @return [Legacy] a new instance of Legacy
  #
  # source://eth//lib/eth/tx/legacy.rb#76
  def initialize(params, chain_id = T.unsafe(nil)); end

  # The transaction amount in Wei.
  #
  # source://eth//lib/eth/tx/legacy.rb#38
  def amount; end

  # The EIP-155 chain ID field.
  # Ref: https://eips.ethereum.org/EIPS/eip-155
  #
  # source://eth//lib/eth/tx/legacy.rb#54
  def chain_id; end

  # The recipient address.
  #
  # source://eth//lib/eth/tx/legacy.rb#35
  def destination; end

  # Encodes a raw transaction object.
  #
  # @raise [Signature::SignatureError] if the transaction is not yet signed.
  # @return [String] a raw, RLP-encoded legacy transaction.
  #
  # source://eth//lib/eth/tx/legacy.rb#230
  def encoded; end

  # The gas limit for the transaction.
  #
  # source://eth//lib/eth/tx/legacy.rb#32
  def gas_limit; end

  # The gas price for the transaction in Wei.
  #
  # source://eth//lib/eth/tx/legacy.rb#29
  def gas_price; end

  # Gets the transaction hash.
  #
  # @return [String] the transaction hash.
  #
  # source://eth//lib/eth/tx/legacy.rb#257
  def hash; end

  # Gets the encoded, raw transaction hex.
  #
  # @return [String] the raw transaction hex.
  #
  # source://eth//lib/eth/tx/legacy.rb#250
  def hex; end

  # The transaction data payload.
  #
  # source://eth//lib/eth/tx/legacy.rb#41
  def payload; end

  # The sender address.
  #
  # source://eth//lib/eth/tx/legacy.rb#57
  def sender; end

  # Sign the transaction with a given key.
  #
  # @param key [Eth::Key] the key-pair to use for signing.
  # @raise [Signature::SignatureError] if transaction is already signed.
  # @raise [Signature::SignatureError] if sender address does not match signing key.
  # @return [String] a transaction hash.
  #
  # source://eth//lib/eth/tx/legacy.rb#205
  def sign(key); end

  # The signature `r` value.
  #
  # source://eth//lib/eth/tx/legacy.rb#47
  def signature_r; end

  # The signature `s` value.
  #
  # source://eth//lib/eth/tx/legacy.rb#50
  def signature_s; end

  # The signature `v` byte.
  #
  # source://eth//lib/eth/tx/legacy.rb#44
  def signature_v; end

  # The transaction nonce provided by the signer.
  #
  # source://eth//lib/eth/tx/legacy.rb#26
  def signer_nonce; end

  # The transaction type.
  #
  # source://eth//lib/eth/tx/legacy.rb#60
  def type; end

  # Encodes the unsigned transaction object, required for signing.
  #
  # @return [String] an RLP-encoded, unsigned transaction.
  #
  # source://eth//lib/eth/tx/legacy.rb#264
  def unsigned_encoded; end

  # Gets the sign-hash required to sign a raw transaction.
  #
  # @return [String] a Keccak-256 hash of an unsigned transaction.
  #
  # source://eth//lib/eth/tx/legacy.rb#281
  def unsigned_hash; end

  private

  # Force-sets an existing signature of a decoded transaction.
  #
  # source://eth//lib/eth/tx/legacy.rb#288
  def _set_signature(v, r, s); end

  # Decodes a raw transaction hex into an {Eth::Tx::Legacy}
  # transaction object.
  #
  # @param hex [String] the raw transaction hex-string.
  # @raise [ParameterError] if transaction misses fields.
  # @return [Eth::Tx::Legacy] transaction object.
  #
  # source://eth//lib/eth/tx/legacy.rb#123
  def decode(hex); end

  # Creates an unsigned copy of a transaction.
  #
  # @param tx [Eth::Tx::Legacy] an legacy transaction object.
  # @raise [TransactionTypeError] if transaction type does not match.
  # @return [Eth::Tx::Legacy] an unsigned transaction object.
  #
  # source://eth//lib/eth/tx/legacy.rb#175
  def unsigned_copy(tx); end

  class << self
    # source://konstructor/1.0.2/lib/konstructor/factory.rb#118
    def decode(*args, &block); end

    # source://konstructor/1.0.2/lib/konstructor/factory.rb#118
    def unsigned_copy(*args, &block); end
  end
end

# Provides a parameter error if parameter types are invalid.
#
# source://eth//lib/eth/tx.rb#37
class Eth::Tx::ParameterError < ::TypeError; end

# The EIP-1559 transaction type is 2.
#
# source://eth//lib/eth/tx.rb#73
Eth::Tx::TYPE_1559 = T.let(T.unsafe(nil), Integer)

# The EIP-2930 transaction type is 1.
#
# source://eth//lib/eth/tx.rb#70
Eth::Tx::TYPE_2930 = T.let(T.unsafe(nil), Integer)

# The legacy transaction type is 0.
#
# source://eth//lib/eth/tx.rb#67
Eth::Tx::TYPE_LEGACY = T.let(T.unsafe(nil), Integer)

# Provides a special transaction error if transaction type is unknown.
#
# source://eth//lib/eth/tx.rb#31
class Eth::Tx::TransactionTypeError < ::TypeError; end

# The zero byte is 0x00.
#
# source://eth//lib/eth/tx.rb#76
Eth::Tx::ZERO_BYTE = T.let(T.unsafe(nil), String)

# Provides constants for common Ethereum units.
#
# source://eth//lib/eth/unit.rb#21
module Eth::Unit
  extend ::Eth::Unit
end

# Ethereum unit 1 babbage := 0.000000000000001 Ether or 1_000 wei.
#
# source://eth//lib/eth/unit.rb#28
Eth::Unit::BABBAGE = T.let(T.unsafe(nil), BigDecimal)

# Ethereum unit 1 Ether := 1_000_000_000_000_000_000 wei.
#
# source://eth//lib/eth/unit.rb#43
Eth::Unit::ETHER = T.let(T.unsafe(nil), BigDecimal)

# Ethereum unit 1 finney := 0.001 Ether or 1_000_000_000_000_000 wei.
#
# source://eth//lib/eth/unit.rb#40
Eth::Unit::FINNEY = T.let(T.unsafe(nil), BigDecimal)

# Ethereum unit 1 Gwei := 0.000000001 Ether or 1_000_000_000 wei.
# Same as shannon, but more commonly used (billion wei).
#
# source://eth//lib/eth/unit.rb#47
Eth::Unit::GWEI = T.let(T.unsafe(nil), BigDecimal)

# Ethereum unit 1 lovelace := 0.000000000001 Ether or 1_000_000 wei.
#
# source://eth//lib/eth/unit.rb#31
Eth::Unit::LOVELACE = T.let(T.unsafe(nil), BigDecimal)

# Ethereum unit 1 shannon := 0.000000001 Ether or 1_000_000_000 wei.
#
# source://eth//lib/eth/unit.rb#34
Eth::Unit::SHANNON = T.let(T.unsafe(nil), BigDecimal)

# Ethereum unit 1 szabo := 0.000_001 Ether or 1_000_000_000_000 wei.
#
# source://eth//lib/eth/unit.rb#37
Eth::Unit::SZABO = T.let(T.unsafe(nil), BigDecimal)

# Ethereum unit 1 wei := 0.000000000000000001 Ether.
#
# source://eth//lib/eth/unit.rb#25
Eth::Unit::WEI = T.let(T.unsafe(nil), BigDecimal)

# Defines handy tools for the {Eth} gem for convenience.
#
# source://eth//lib/eth/util.rb#21
module Eth::Util
  extend ::Eth::Util

  # Converts a big endian to an interger.
  #
  # @param str [String] big endian to be converted.
  # @return [Integer] an unpacked integer number.
  #
  # source://eth//lib/eth/util.rb#146
  def big_endian_to_int(str); end

  # Unpacks a binary string to a hexa-decimal string.
  #
  # @param bin [String] a binary string to be unpacked.
  # @raise [TypeError] if value is not a string.
  # @return [String] a hexa-decimal string.
  #
  # source://eth//lib/eth/util.rb#49
  def bin_to_hex(bin); end

  # Unpacks a binary string to a prefixed hexa-decimal string.
  #
  # @param bin [String] a binary string to be unpacked.
  # @return [String] a prefixed hexa-decimal string.
  #
  # source://eth//lib/eth/util.rb#89
  def bin_to_prefixed_hex(bin); end

  # Checks if a string is a byte-string.
  #
  # @param str [String] a string to check.
  # @return [Boolean] true if it's an ASCII-8bit encoded byte-string.
  #
  # source://eth//lib/eth/util.rb#170
  def bytes?(str); end

  # Converts bytes to a binary string.
  #
  # @param bin [Object] bytes to be converted.
  # @return [String] a packed binary string.
  #
  # source://eth//lib/eth/util.rb#162
  def bytes_to_str(bin); end

  # Ceil and integer to the next multiple of 32 bytes.
  #
  # @param num [Integer] the number to ciel up.
  # @return [Integer] the ceiled to 32 integer.
  #
  # source://eth//lib/eth/util.rb#194
  def ceil32(num); end

  # Deserializes big endian data string to integer.
  #
  # @param str [String] serialized big endian integer string.
  # @return [Integer] an deserialized unsigned integer.
  #
  # source://eth//lib/eth/util.rb#138
  def deserialize_big_endian_to_int(str); end

  # Checks if a string is hex-adecimal.
  #
  # @param str [String] a string to be checked.
  # @return [String] a match if true; `nil` if not.
  #
  # source://eth//lib/eth/util.rb#97
  def hex?(str); end

  # Packs a hexa-decimal string into a binary string. Also works with
  # `0x`-prefixed strings.
  #
  # @param hex [String] a hexa-decimal string to be packed.
  # @raise [TypeError] if value is not a string or string is not hex.
  # @return [String] a packed binary string.
  #
  # source://eth//lib/eth/util.rb#60
  def hex_to_bin(hex); end

  # Converts an integer to big endian.
  #
  # @param num [Integer] integer to be converted.
  # @return [String] packed, big-endian integer string.
  #
  # source://eth//lib/eth/util.rb#128
  def int_to_big_endian(num); end

  # Hashes a string with the Keccak-256 algorithm.
  #
  # @param str [String] a string to be hashed.
  # @return [String] a Keccak-256 hash of the given string.
  #
  # source://eth//lib/eth/util.rb#40
  def keccak256(str); end

  # Checks if the given item is a list.
  #
  # @param item [Object] the item to check.
  # @return [Boolean] true if it's a list.
  #
  # source://eth//lib/eth/util.rb#186
  def list?(item); end

  # Left-pad a number with a symbol.
  #
  # @param str [String] a serialized string to be padded.
  # @param sym [String] a symbol used for left-padding.
  # @param len [Integer] number of symbols for the final string.
  # @return [String] a left-padded serialized string of wanted size.
  #
  # source://eth//lib/eth/util.rb#204
  def lpad(str, sym, len); end

  # Prefixes a hexa-decimal string with `0x`.
  #
  # @param hex [String] a hex-string to be prefixed.
  # @return [String] a prefixed hex-string.
  #
  # source://eth//lib/eth/util.rb#71
  def prefix_hex(hex); end

  # Checks if a string is prefixed with `0x`.
  #
  # @param hex [String] a string to be checked.
  # @return [String] a match if true; `nil` if not.
  #
  # source://eth//lib/eth/util.rb#107
  def prefixed?(hex); end

  # Checks if the given item is a string primitive.
  #
  # @param item [Object] the item to check.
  # @return [Boolean] true if it's a string primitive.
  #
  # source://eth//lib/eth/util.rb#178
  def primitive?(item); end

  # Generates an Ethereum address from a given compressed or
  # uncompressed binary or hexadecimal public key string.
  #
  # @param str [String] the public key to be converted.
  # @return [Eth::Address] an Ethereum address.
  #
  # source://eth//lib/eth/util.rb#29
  def public_key_to_address(str); end

  # Removes the `0x` prefix of a hexa-decimal string.
  #
  # @param hex [String] a prefixed hex-string.
  # @return [String] an unprefixed hex-string.
  #
  # source://eth//lib/eth/util.rb#80
  def remove_hex_prefix(hex); end

  # Serializes an unsigned integer to big endian.
  #
  # @param num [Integer] unsigned integer to be serialized.
  # @raise [ArgumentError] if unsigned integer is out of bounds.
  # @return [String] serialized big endian integer string.
  #
  # source://eth//lib/eth/util.rb#116
  def serialize_int_to_big_endian(num); end

  # Converts a binary string to bytes.
  #
  # @param str [String] binary string to be converted.
  # @return [Object] the string bytes.
  #
  # source://eth//lib/eth/util.rb#154
  def str_to_bytes(str); end

  # Left-pad a serialized string with zeros.
  #
  # @param str [String] a serialized string to be padded.
  # @param len [Integer] number of symbols for the final string.
  # @return [String] a zero-padded serialized string of wanted size.
  #
  # source://eth//lib/eth/util.rb#214
  def zpad(str, len); end

  # Left-pad a hex number with zeros.
  #
  # @param hex [String] a hex-string to be padded.
  # @param len [Integer] number of symbols for the final string.
  # @return [String] a zero-padded serialized string of wanted size.
  #
  # source://eth//lib/eth/util.rb#223
  def zpad_hex(hex, len = T.unsafe(nil)); end

  # Left-pad an unsigned integer with zeros.
  #
  # @param num [Integer] an unsigned integer to be padded.
  # @param len [Integer] number of symbols for the final string.
  # @return [String] a zero-padded serialized string of wanted size.
  #
  # source://eth//lib/eth/util.rb#232
  def zpad_int(num, len = T.unsafe(nil)); end
end

# Defines the version string of the {Eth} module.
#
# source://eth//lib/eth/version.rb#28
Eth::VERSION = T.let(T.unsafe(nil), String)
