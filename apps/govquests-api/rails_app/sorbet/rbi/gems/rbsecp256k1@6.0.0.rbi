# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rbsecp256k1` gem.
# Please instead update this file by running `bin/tapioca gem rbsecp256k1`.


# Wraps libsecp256k1 in a ruby module and provides object interfaces.
#
# source://rbsecp256k1//lib/rbsecp256k1.rb#4
module Secp256k1
  class << self
    def have_ecdh?; end
    def have_recovery?; end
    def have_schnorr?; end
  end
end

# Wrapper around a secp256k1_context object.
#
# source://rbsecp256k1//lib/rbsecp256k1/context.rb#7
class Secp256k1::Context
  def initialize(*_arg0); end

  def ecdh(_arg0, _arg1); end

  # Generates a new random key pair.
  #
  # @return [Secp256k1::KeyPair] public-private key pair.
  #
  # source://rbsecp256k1//lib/rbsecp256k1/context.rb#25
  def generate_key_pair; end

  def key_pair_from_private_key(_arg0); end
  def recoverable_signature_from_compact(_arg0, _arg1); end
  def sign(_arg0, _arg1); end
  def sign_recoverable(_arg0, _arg1); end

  # Create Schnorr signature generating auxrand.
  #
  # @return [Secp256k1::SchnorrSignature] schnorr signature
  #
  # source://rbsecp256k1//lib/rbsecp256k1/context.rb#32
  def sign_schnorr(keypair, message); end

  def sign_schnorr_custom(_arg0, _arg1, _arg2); end
  def tagged_sha256(_arg0, _arg1); end
  def verify(_arg0, _arg1, _arg2); end

  class << self
    # Create a new randomized context.
    #
    # @return [Secp256k1::Context] randomized context
    #
    # source://rbsecp256k1//lib/rbsecp256k1/context.rb#11
    def create; end

    # Create a new non-randomized context.
    #
    # @return [Secp256k1::Context] non-randomized context
    #
    # source://rbsecp256k1//lib/rbsecp256k1/context.rb#18
    def create_unrandomized; end
  end
end

class Secp256k1::DeserializationError < ::Secp256k1::Error; end
class Secp256k1::Error < ::StandardError; end

class Secp256k1::KeyPair
  def ==(_arg0); end
  def private_key; end
  def public_key; end
  def xonly_public_key; end
end

class Secp256k1::PrivateKey
  def ==(_arg0); end
  def data; end

  class << self
    def from_data(_arg0); end
  end
end

class Secp256k1::PublicKey
  def ==(_arg0); end
  def compressed; end
  def to_xonly; end
  def uncompressed; end

  class << self
    def from_data(_arg0); end
  end
end

class Secp256k1::RecoverableSignature
  def ==(_arg0); end
  def compact; end
  def recover_public_key(_arg0); end
  def to_signature; end
end

class Secp256k1::SchnorrSignature
  def ==(_arg0); end
  def serialized; end
  def verify(_arg0, _arg1); end

  class << self
    def from_data(_arg0); end
  end
end

class Secp256k1::SerializationError < ::Secp256k1::Error; end

class Secp256k1::SharedSecret
  def data; end
end

class Secp256k1::Signature
  def ==(_arg0); end
  def compact; end
  def der_encoded; end
  def normalized; end

  class << self
    def from_compact(_arg0); end
    def from_der_encoded(_arg0); end
  end
end

# Contains utility methods that complement the functionality of the library.
#
# source://rbsecp256k1//lib/rbsecp256k1/util.rb#5
module Secp256k1::Util
  class << self
    # Converts a binary string to a hex string.
    #
    # @param binary_string [String] binary string to be converted.
    # @return [String] hex string equivalent of the given binary string.
    #
    # source://rbsecp256k1//lib/rbsecp256k1/util.rb#13
    def bin_to_hex(binary_string); end

    # Converts a hex string to a binary string.
    #
    # @param hex_string [String] string with hexadeimcal value.
    # @raise [ArgumentError] if hex string is an invalid hexadecimal string.
    # @return [String] binary string equivalent of the given hex string.
    #
    # source://rbsecp256k1//lib/rbsecp256k1/util.rb#22
    def hex_to_bin(hex_string); end
  end
end

# Regexp to validate a hexadecimal string
#
# source://rbsecp256k1//lib/rbsecp256k1/util.rb#7
Secp256k1::Util::HEX_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://rbsecp256k1//lib/rbsecp256k1/version.rb#4
Secp256k1::VERSION = T.let(T.unsafe(nil), String)

class Secp256k1::XOnlyPublicKey
  def ==(_arg0); end
  def serialized; end

  class << self
    def from_data(_arg0); end
  end
end
